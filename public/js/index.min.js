(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.App = factory());
}(this, (function () { 'use strict';

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	!function(){var e,n,o,t,i=[];function d(e,n,o,t,i){if("string"==typeof e){for(t in o={name:e,props:{},children:[],dom:null,isVnode:!0,nt:1,isSVG:"svg"===e},n){ o.props[t]=n[t]; }return d.utils.flat(arguments,2,o.children,!0),o}return "function"==typeof e?Object.assign({view:e,isComponent:!0},n):"object"==typeof e&&("function"==typeof e.view&&Object.assign(e,{isComponent:!0}),e.isComponent)?(i=e.view.apply(e,d.utils.flat(arguments,1,[])),Array.isArray(i)?i:[i]):void 0}function r(e,n){return 3===e.nodeType?{name:"#text",isVnode:!0,nodeValue:e.nodeValue,children:[],dom:e,nt:3}:1===e.nodeType?("svg"===(n={name:e.nodeName.toLowerCase(),props:{},children:[],dom:e,isVnode:!0,nodeValue:null,nt:1}).name&&(n.isSVG=!0),n.dom.events={},Array.prototype.map.call(e.attributes,function(e){n.props[e.nodeName]=e.nodeValue;}),Array.prototype.forEach.call(e.childNodes,function(e){var o=r(e);void 0!==o&&n.children.push(o);}),n):void 0}function s(e,n,o,t,i){if(1===e.nt&&(void 0!==e.props[n]&&e.props[n](e,o),"onremove"===n)){for(t=0,i=e.children.length;t<i;t++){ s(e.children[t],"onremove"); }e.children=[];}}function l(e){void 0!==e.currentTarget.events["on"+e.type]&&e.currentTarget.events["on"+e.type](e),d.update();}d.utils={flat:function(e,n,o,t,i){for(i=e.length,void 0===t&&(t=!1);n<i;n++){ Array.isArray(e[n])?o=d.utils.flat(e[n],0,o):(!1===t||void 0!==e[n]&&null!==e[n])&&o.push(e[n]); }return o}},(d.is={node:"undefined"==typeof window,mounted:!1,updating:!1}).browser=!d.is.node,d.trust=function(e){var n=document.createElement("div");return n.innerHTML=e.trim(),Array.prototype.map.call(n.childNodes,function (e){ return r(e); })},d.update=function(i){return "object"==typeof(i=d.utils.flat(arguments,0,[]))[0]&&i[0].isComponent&&(e=i.shift()),new Promise(function(r){if(!d.is.updating){if(d.is.updating=!0,i.unshift(e),o=d.apply(d,i),function e(n,o,t,i,r,u,p,a,m,c){if(0!==o.length){ for(r=o.length>t.length?o.length:t.length,a=0;a<r;a++){ if(p=t[a],void 0!==(u=o[a])){ if(void 0!==u.nt&&3!==u.nt){if(m=!d.is.mounted,i=i||u.isSVG,void 0===p){ s(u,"oninit"),u.dom=i?document.createElementNS("http://www.w3.org/2000/svg",u.name):document.createElement(u.name),u.dom.events={},n.appendChild(u.dom),p={children:[]},m=!0; }else if(u.name!==p.name){ s(u,"oninit"),u.dom=i?document.createElementNS("http://www.w3.org/2000/svg",u.name):document.createElement(u.name),u.dom.events={},s(p,"onremove"),n.replaceChild(u.dom,p.dom),m=!0; }else { for(c in u.dom=p.dom,p.props){ if(void 0===u.props[c]){if("function"==typeof p.props[c]){u.dom.removeEventListener(c.slice(2),l);continue}if(d.is.node||i||void 0===u.dom[c]){u.dom.removeAttribute(c);continue}u.dom[c]=null;} } }for(c in e(u.dom,u.children,p.children,i),u.props){ if((m||u.props[c]!==p.props[c])&&void 0!==u.props[c]){if("function"==typeof u.props[c]){switch(c){case"oninit":case"oncreate":case"onupdate":case"onremove":break;default:void 0===u.dom.events[c]&&(u.dom.events[c]=u.props[c],u.dom.addEventListener(c.slice(2),l));}continue}if(d.is.node||i||void 0===u.dom[c]){u.dom.setAttribute(c,u.props[c]);continue}u.dom[c]=u.props[c];} }d.is.mounted||m||(s(u,"oninit"),s(u,"oncreate")),s(u,m?"oncreate":"onupdate",p);}else { void 0===u.nt&&(o[a]=u={name:"#text",isVnode:!0,nodeValue:u,children:[],nt:3}),void 0===p?(u.dom=document.createTextNode(u.nodeValue),n.appendChild(u.dom)):1===p.nt?(u.dom=document.createTextNode(u.nodeValue),s(p,"onremove"),n.replaceChild(u.dom,p.dom)):(u.dom=p.dom,u.nodeValue!=p.nodeValue&&(u.dom.nodeValue=u.nodeValue)); } }else { void 0!==p&&(3===p.nt&&s(p,"onremove"),n.removeChild(p.dom)); } } }else { n.textContent=""; }}(t,o,n),n=o,d.is.updating=!1,d.is.mounted=!0,d.is.node){ return r(t.innerHTML); }r();}})},d.mount=function(e,o){return t=d.is.node?document.createElement("div"):"string"==typeof e?document.querySelectorAll(e)[0]:e,n=r(t).children,d.update.apply(this,d.utils.flat(arguments,1,[]))},d.use=function(e,n){return -1===i.indexOf(e)&&(e(d,n),i.push(e)),d},(d.is.node?commonjsGlobal:window).v=d;}();

	var plugin = function (v) {
	    var Request = function (baseUrl, options) {
	        if ( baseUrl === void 0 ) baseUrl = '';
	        if ( options === void 0 ) options = {};

	        var url = baseUrl.replace(/\/$/gi, '').trim(),
	            opts = Object.assign({
	                methods: ['get', 'post', 'put', 'patch', 'delete']
	            }, options),
	            parseUrl;

	        function serialize(obj, prefix) {
	            var e = encodeURIComponent;
	            return Object.keys(obj)
	                .map(function (p) {
	                    var k = prefix ? prefix + '[' + p + ']' : p;

	                    return typeof obj[p] === 'object'
	                        ? serialize(obj[p], k)
	                        : e(k) + '=' + e(obj[p]);
	                })
	                .join('&');
	        }

	        function request(method, url, data, options) {
	            if ( options === void 0 ) options = {};

	            var opts = Object.assign({
	                    method: method.toLowerCase(),
	                    headers: {
	                        'Accept': 'application/json',
	                        'Content-Type': 'application/json'
	                    }
	                }, request.options, options),
	                type = opts.headers.Accept;

	            if (data !== undefined) {
	                if (opts.method === 'get' && typeof data === 'object') {
	                    url += data = serialize(data);
	                }

	                if (opts.method !== 'get') {
	                    opts.body = JSON.stringify(data);
	                }
	            }

	            return fetch(parseUrl(url), opts)
	                .then(function (response) {
	                    if (!response.ok) {
	                        var err = new Error(response.statusText);
	                        err.response = response;
	                        throw err;
	                    }

	                    if (/text/gi.test(type)) {
	                        return response.text();
	                    }

	                    if (/json/gi.test(type)) {
	                        return response.json();
	                    }

	                    return response;
	                });
	        }
	        parseUrl = function (url) {
	            var u = /^https?/gi.test(url)
	                ? url
	                : (request.urls.base + '/' + url).trim().replace(/^\/\//gi, '/').trim();

	            if (
	                v.is.node &&
	                typeof request.urls.node === 'string'
	            ) {
	                request.urls.node = request.urls.node.replace(/\/$/gi, '').trim();

	                if (/^https?/gi.test(u) && typeof request.urls.api === 'string') {
	                    request.urls.api = request.urls.api.replace(/\/$/gi, '').trim();
	                    u = u.replace(request.urls.api, request.urls.node);
	                }

	                if (!/^https?/gi.test(u)) {
	                    u = request.urls.node + u;
	                }
	            }

	            return u;
	        };

	        request.new = function (baseUrl, options) {
	            return Request(baseUrl, options);
	        };

	        request.urls = {};
	        request.urls.api = undefined;
	        request.urls.node = undefined;
	        request.urls.base = url;
	        request.options = opts;

	        opts.methods.forEach(function (method) { return request[method] = function (url, data, options) { return request(method, url, data, options); }; }
	        );

	        return request;
	    };

	    v.request = Request();
	};

	function __async(g){return new Promise(function(s,j){function c(a,x){try{var r=g[x?"throw":"next"](a);}catch(e){j(e);return}r.done?s(r.value):Promise.resolve(r.value).then(c,d);}function d(e){c(e,1);}c();})}

	/**
	 * Handles the mix of single and array of middlewares
	 * @method parseMiddlewares
	 * @param  {Function|Array}         middlewares     // Middleware or array of middlewares
	 * @param  {Array}                  [array=[]]      // The array to store the final list of middlewares
	 * @return {Array}                                  // The final list of middlewares
	 */
	var parseMiddlewares = function (middlewares, array) {
	    if ( array === void 0 ) array = [];

	    if (typeof middlewares === 'function') {
	        array.push(middlewares);
	        return array;
	    }

	    var i = 0, l = middlewares.length;
	    for (; i < l; i++) {
	        if (Array.isArray(middlewares[i])) {
	            parseMiddlewares(middlewares[i], array);
	            continue;
	        }

	        array.push(middlewares[i]);
	    }
	    return array;
	};

	/**
	 * @description Adds a path to a router
	 * @method addPath
	 * @param  {Router} router              The router in which to add the path
	 * @param  {String} method              The method that will handle this path
	 * @param  {Array} args                The mixed params (String|Function|Array)
	 * @returns {Router}                    The router
	 */
	var addPath = function (router, method, args) {
	    var path, middlewares;

	    // Get the first argument
	    if (typeof args[0] === 'string') {
	        path = args.shift();
	    }

	    // If the seccond argument is a function and has paths
	    // and regexpList properties then
	    // Treat it as a subrouter
	    if (
	        typeof args[0] === 'function' &&
	        args[0].paths &&
	        args[0].regexpList
	    ) {
	        var subrouter = args.shift(),
	            i = 0,
	            l = subrouter.paths.length;

	        // For each path of the subrouter
	        for (; i < l; i++) {
	            var submiddlewares = subrouter.paths[i].middlewares;
	            var submethod = subrouter.paths[i].method;
	            var subpath = subrouter.paths[i].path;

	            // If there is a path add it as prefix to the subpath
	            if (path) {
	                subpath = path + (subpath || '*');
	            }

	            // If there is a subpath set it as the first element
	            // on the submiddlewares array
	            if (subpath) {
	                submiddlewares.unshift(subpath);
	            }

	            // Add the path to the router
	            router = addPath(router, submethod, submiddlewares);
	        }
	    }

	    // Parse middlwares to handle mixed arrays of middlwares and sequenced middlwares
	    middlewares = parseMiddlewares(args);

	    // Add the path only if there are middlewares passed
	    if (middlewares.length > 0) {
	        // If the path wasn't set before, set the regexp and params list
	        if (path && router.regexpList[path] === undefined) {
	            // Remove the last slash
	            path = path.replace(/\/(\?.*)?$/gi, '$1');

	            // Find the express like params
	            var params = path.match(/:(\w+)?/gi) || [];

	            // Set the names of the params found
	            for (var i$1 in params) {
	                params[i$1] = params[i$1].slice(1);
	            }

	            var regexpPath = path
	                // Catch params
	                .replace(/:(\w+)/gi, '([^\\s\\/|\\?]+)')
	                // To set to any url with the path as prefix
	                .replace(/\*/g, '.*')
	                // Remove the last slash
	                .replace(/\/(\?.*)?$/gi, '$1');

	            // Set the object to the path
	            router.regexpList[path] = {
	                regexp: new RegExp('^' + regexpPath + '/?(\\?.*)?$', 'gi'),
	                params: params
	            };
	        }

	        // Add the path to the paths list
	        router.paths.push({
	            method: method,
	            path: path,
	            middlewares: middlewares
	        });
	    }

	    return router;
	};

	var RouterFactory = function () {
	    /**
	     * new Rotuer
	     * @param  {String}    url     The path to call
	     * @return {Any}           The final response
	     */
	    var Router = function (url) {
	    if ( url === void 0 ) url = '/';
	return __async(function*(){
	        var method = 'get',
	            params = {},
	            middlewares = [],
	            response,
	            i = 0,
	            l = Router.paths.length;

	        Router.url = url;

	        for (; i < l; i++) {
	            var path = Router.paths[i];
	            if (method !== path.method && path.method !== 'use') {
	                continue;
	            }

	            if ((path.method === 'use' || method === path.method) && path.path === undefined) {
	                parseMiddlewares(path.middlewares, middlewares);
	                continue;
	            }

	            var reg = Router.regexpList[path.path];
	            var matches = reg.regexp.exec(url);
	            reg.regexp.lastIndex = -1;
	            if (Array.isArray(matches)) {
	                matches.shift();
	                var regparams = reg.params;
	                var l$1 = regparams.length;
	                for (; l$1--;) {
	                    if (params[regparams[l$1]] === undefined) {
	                        params[regparams[l$1]] = matches[l$1];
	                    }
	                }
	                parseMiddlewares(path.middlewares, middlewares);
	            }
	        }

	        Router.params = params;

	        if (middlewares.length > 0) {
	            var i$1 = 0, l$2 = middlewares.length;
	            // call sequentially every middleware
	            for (; i$1 < l$2; i$1++) {
	                response = yield middlewares[i$1](params);
	                // If there is a response
	                // break the for block
	                if (response) {
	                    return response;
	                }
	            }
	        }

	        if (Router.throwNotFound) {
	            // If no response was sent to the client throw an error
	            throw new Error(("The url " + url + " requested wasn't found"));
	        }
	    }())};

	    Router.url = '/';
	    Router.params = {};
	    Router.throwNotFound = true;

	    /**
	     * Where to store the paths and its middlewares
	     * @type {Object}
	     */
	    Router.paths = [];

	    /**
	     * Where to store the regexp and params list for the paths
	     * @type {[type]}
	     */
	    Router.regexpList = {};

	    // For each accepted method, add the method to the router
	    Router.get = function () {
	        return addPath(Router, 'get', v.utils.flat(arguments, 0, []));
	    };
	    Router.use = function () {
	        return addPath(Router, 'use', v.utils.flat(arguments, 0, []));
	    };

	    /**
	     * Return the new router
	     * @type {Router}
	     */
	    return Router;
	};


	var plugin$1 = function (v) {
	    var mainRouter;
	    var RoutesContainer;
	    function runRoute(parentComponent, url, args) {
	        return mainRouter(url)
	            .then(function (response) {
	                if (typeof response !== 'object') {
	                    throw new Error('v.router.component.required');
	                }

	                if (!response.isComponent && typeof response.view === 'function') {
	                    Object.assign(response, {isComponent: true});
	                }

	                if (!response.isComponent) {
	                    throw new Error('v.router.component.required');
	                }

	                if (parentComponent) {
	                    args.unshift(v(response, args));
	                    response = parentComponent;
	                }

	                args.unshift(response);

	                if (v.is.node || !v.is.mounted) {
	                    args.unshift(RoutesContainer);
	                    return v.mount.apply(v, args);
	                }

	                return v.update.apply(v, args);
	            });
	    }
	    v.routes = function (elementContainer, router) {
	        if (elementContainer && router) {
	            mainRouter = router;
	            RoutesContainer = elementContainer;
	            // Activate the use of the router
	            if (v.is.browser) {
	                function onPopStateGoToRoute() {
	                    v.routes.go(document.location.pathname);
	                }
	                window.addEventListener('popstate', onPopStateGoToRoute, false);
	                onPopStateGoToRoute();
	            }
	        }
	    };

	    v.routes.get = function () {
	        var routes = [];
	        mainRouter.paths.forEach(function (path) {
	            if (path.method === 'get') {
	                routes.push(path.path === '' ? '/' : path.path);
	            }
	        });
	        return routes;
	    };

	    v.routes.current = '/';
	    v.routes.params = {};

	    v.routes.go = function () {
	        var args = v.utils.flat(arguments, 0, []);
	        var parentComponent;
	        var url;

	        if (typeof args[0] === 'object') {
	            if (!args[0].isComponent && typeof args[0].view === 'function') {
	                args[0] = Object.assign(args[0], {isComponent: true});
	            }

	            if (args[0].isComponent) {
	                parentComponent = args.shift();
	            }
	        }

	        if (typeof args[0] === 'string') {
	            url = args.shift();
	        }

	        if (!url) {
	            throw new Error('v.router.url.required');
	        }

	        if (v.is.browser) {
	            window.history.pushState({}, '', url);
	        }

	        return runRoute(parentComponent, url, args);
	    };

	    v.Router = RouterFactory;
	};

	v
	    .use(plugin$1)
	    .use(plugin)
	;

	var displayName = "MonkeyTown.io";
	var description = "Build your monkey home and survive";
	var version = "0.0.1";

	var Main = {
	    title: displayName,
	    version: version,
	    description: description,
	    id: (0 | Math.random() * 6.04e7).toString(36), // change this to version when publish
	    view: function view() {
	        var children = [], len = arguments.length;
	        while ( len-- ) children[ len ] = arguments[ len ];

	        var view = v( 'html', { lang: "en" },
	            v( 'head', null,
	                v( 'title', null, Main.title ),
	                v( 'meta', { charset: "utf-8" }),
	                v( 'meta', { name: "description", content: Main.description }),
	                v( 'meta', { 'http-equiv': "x-UA-Compatible", content: "IE=edge" }),
	                v( 'meta', { name: "viewport", content: "width=device-width, initial-scale=1, maximum-scale=5, minimal-ui" }),
	                v( 'link', { href: ("/css/main.css?v=" + (Main.id)), rel: "stylesheet" }),
	                v( 'link', { rel: "shortcut icon", href: "/imgs/favicon.ico" })
	            ),
	            v( 'body', null,
	                v( 'div', { id: "ui" },
	                    children,
	                    v( 'script', { src: ("/js/socket.io.js?v=" + (Main.id)) }),
	                    v( 'script', { src: ("/js/three.min.js?v=" + (Main.id)) }),
	                    v( 'script', { src: ("/js/index.min.js?v=" + (Main.id)) })
	                )
	            )
	        );

	        return view;
	    }
	};

	var Panel = v(function (props) {
	    var children = [], len = arguments.length - 1;
	    while ( len-- > 0 ) children[ len ] = arguments[ len + 1 ];

	    return v( 'section', { 'data-panel': props.position, 'data-background': props.color },
	        v( 'nav', null, props.title ),
	        v( 'div', null, children )
	    );
	});

	var config = {
	    dev: true,
	    localUrl: 'http://localhost:3000',
	    serverUrl: 'http://localhost:3000'
	};

	var AppFactory = function (Game) {
	    Game.app = {};

	    Game.app.scene = new THREE.Scene();
	    Game.app.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
	    Game.app.camera.position.set(0, 100, 100);
	    Game.app.camera.lookAt(new THREE.Vector3(0, 0, 0));
	    Game.app.scene.add(Game.app.camera);

	    Game.app.mixer = new THREE.AnimationMixer(Game.app.scene);

	    Game.app.listener = new THREE.AudioListener();
	    Game.app.camera.add(Game.app.listener);

	    Game.app.renderer = new THREE.WebGLRenderer({ antialias: true });
	    Game.app.renderer.setPixelRatio(window.devicePixelRatio);
	    Game.app.renderer.setSize(window.innerWidth, window.innerHeight);
	    Game.app.renderer.shadowMap.enabled = true;
	    Game.app.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	    Game.canvas = Game.app.renderer.domElement;

	    document.body.appendChild(Game.canvas);
	    Game.canvas.setAttribute('tabindex', '0');
	    Game.canvas.setAttribute('id', 'game-canvas');

	    window.addEventListener('resize', function () {
	        Game.app.camera.aspect = window.innerWidth / window.innerHeight;
	        Game.app.camera.updateProjectionMatrix();
	        Game.app.renderer.setSize(window.innerWidth, window.innerHeight);
	    });


	    Game.app.light = new THREE.DirectionalLight(0xffffff, 0.9);
	    Game.app.light.position.set(2, 4, 3);
	    Game.app.light.castShadow = true;
	    Game.app.scene.add(Game.app.light);

	    Game.app.ambientlight = new THREE.AmbientLight(0x999999);
	    Game.app.scene.add(Game.app.ambientlight);


	    Game.app.ground = new THREE.Mesh(
	        new THREE.PlaneGeometry(1000, 1000),
	        new THREE.MeshStandardMaterial({color: 0x9cff57, side: THREE.DoubleSide})
	    );
	    Game.app.ground.rotation.x = -(Math.PI / 2);
	    Game.app.ground.castShadow = false;
	    Game.app.ground.receiveShadow = true;
	    Game.app.ground.position.set(0, 0, 0);
	    Game.app.scene.add(Game.app.ground);
	};

	var ConnectionFactory = function (Game) {
	    var Connection = {
	        initSocket: function initSocket(url) {
	            if (Game.socket !== undefined) {
	                Game.socket.disconnect();
	                Game.socket = undefined;
	            }

	            Game.socket = io(url);

	            /**
	             * As we will destroy the player when socket disconnects
	             * with this we will reload the browser page if the user recconnects
	             */
	            Game.socket.on('reconnect', function () { return window.location.href = window.location.href; });

	            // Custom game events
	            Game.socket.on('world', function (data) { return Game.updateWorld(data); });
	        },
	        connectServer: function connectServer(world) {
	            if ( world === void 0 ) world = 'Alpha';

	            return new Promise(function (resolve) {
	                Game.socket.emit('connectServer', world, function (err, entity) {
	                    if (err) {
	                        console.error(err);
	                        return;
	                    }
	                    entity.socket = Game.socket;
	                    resolve(entity);
	                });
	            });
	        },
	        getWorlds: function () { return new Promise(function (resolve) { return Game.socket.emit('getWorlds', resolve); }); }
	    };
	    return Connection;
	};

	var Factory = function () {
	    var sphere = new THREE.Mesh(
	        new THREE.SphereGeometry(1, 32, 32),
	        new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide })
	    );
	    sphere.receiveShadow = true;
	    sphere.castShadow = true;

	    return {
	        Model: sphere,
	        initServer: function initServer(entity) {

	        },
	        initClient: function initClient(entity) {

	        }
	    };
	};

	var playerEntityFactory = Factory;

	var NET_TYPES = {
	    Player: 0
	};

	var ENTITIES = {};
	ENTITIES[NET_TYPES.Player] = playerEntityFactory;

	// NOTE: Set only the props that will be sent to the client
	var PROPS = {
	    netType: 'n',
	    position: 'p',
	    quaternion: 'q',
	    scale: 's',
	    lerp: 'l'
	};

	var config$1 = {PROPS: PROPS, NET_TYPES: NET_TYPES, ENTITIES: ENTITIES};

	var PROPS$1 = config$1.PROPS;
	var NET_TYPES$1 = config$1.NET_TYPES;
	var ENTITIES$1 = config$1.ENTITIES;

	var Entities = {
	    isNode: typeof window === 'undefined',
	    PROPS: PROPS$1,
	    NET_TYPES: NET_TYPES$1,
	    Factories: {},
	    init: function init() {
	        for (var nt in ENTITIES$1) {
	            Entities.Factories[nt] = ENTITIES$1[nt]();
	        }
	    },
	    create: function create(data) {
	        if ( data === void 0 ) data = {};

	        var entity = {
	            id: data.id || (0 | Math.random() * 6.04e7).toString(36),
	            body: new THREE.Object3D(),
	            parent: undefined,
	            remove: false
	        };
	        entity[PROPS$1.netType] = data[PROPS$1.netType] || 0;
	        entity[PROPS$1.position] = data[PROPS$1.position] || {x: 0, y: 1, z: 0};
	        entity[PROPS$1.quaternion] = data[PROPS$1.quaternion] || {x: 0, y: 0, z: 0, w: 0};
	        entity[PROPS$1.scale] = data[PROPS$1.scale] || 1;
	        entity[PROPS$1.lerp] = data[PROPS$1.lerp] || 1;
	        entity.destroy = function destroy() {
	                if (entity && entity.body && entity.body.parent) {
	                    entity.body.parent.remove(entity.body);
	                }

	                if (Entities.isNode) {
	                    delete Game.worlds[entity.world].children[entity.id];
	                }

	                delete entity.parent.children[entity.id];
	                entity = undefined;
	            };
	        entity.update = function update(dt) {
	                // Update position on the client
	                if (!Entities.isNode) {
	                    if (entity[PROPS$1.lerp] === 1) {
	                        entity.body.position.copy(entity[PROPS$1.position]);
	                    } else if (entity[PROPS$1.lerp] < 1) {
	                        entity.body.position.lerp(
	                            new THREE.Vector3(
	                                entity[PROPS$1.position].x,
	                                entity[PROPS$1.position].y,
	                                entity[PROPS$1.position].z
	                            ),
	                            entity[PROPS$1.lerp]
	                        );
	                    }

	                    entity.body.quaternion.copy(entity[PROPS$1.quaternion]);
	                }

	                entity.runScript('start', dt);

	                entity.runEveryTimers(dt);

	                entity.runScript('tick', dt);

	                // Copy position that will be sent to the client
	                if (Entities.isNode) {
	                    entity[PROPS$1.position] = entity.body.position;
	                    entity[PROPS$1.quaternion] = entity.body.quaternion;
	                }

	                entity.runScript('end', dt);

	                if (Entities.isNode && entity.remove) {
	                    entity.destroy();
	                }
	            };
	        entity.every = function every(nameOrTime, handler) {
	                if (entity.timers[nameOrTime] === undefined) {
	                    entity.timers[nameOrTime] = {
	                        timer: Date.now(),
	                        handlers: []
	                    };
	                }

	                if (typeof handler === 'function') {
	                    entity.timers[nameOrTime].handlers.push(handler);
	                }
	                return;
	            };
	        entity.runEveryTimers = function runEveryTimers(dt) {
	                for (var i in entity.timers) {
	                    if (
	                        entity.timers[i].handlers.length > 0 &&
	                        Date.now() - entity.timers[i].timer > +i
	                    ) {
	                        for (var k = 0, l = entity.timers[i].handlers.length; k < l; k++) {
	                            entity.timers[i].handlers[k](dt);
	                        }
	                        entity.timers[i].timer = Date.now();
	                    }
	                }
	            };
	        entity.timers = {
	                // '100': {timer: Date.now(), handlers: []},
	            };
	        entity.addScript = function addScript(name, handler) {
	                if (entity.scripts[name] === undefined) {
	                    entity.scripts[name] = [];
	                }

	                if (typeof handler === 'function') {
	                    entity.scripts[name].push(handler);
	                }
	            };
	        entity.runScript = function runScript(name) {
	                var ref;

	                var args = [], len = arguments.length - 1;
	                while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];
	                if (entity.scripts[name].length > 0) {
	                    for (var i = 0, l = entity.scripts[name].length; i < l; i++) {
	                        (ref = entity.scripts[name])[i].apply(ref, args);
	                    }
	                }
	            };
	        entity.scripts = {
	                'start': [],
	                'tick': [],
	                'end': []
	            };

	        // Clone the model and set its initial position
	        // At serverside we don't need the real model, just handle the Object3D props
	        if (!Entities.isNode && Entities.Factories[data[PROPS$1.netType]].Model) {
	            entity.body.add(Entities.Factories[data[PROPS$1.netType]].Model.clone());
	        }

	        entity.body.position.set(
	            entity[PROPS$1.position].x,
	            entity[PROPS$1.position].y,
	            entity[PROPS$1.position].z
	        );

	        entity.body.quaternion.set(
	            entity[PROPS$1.quaternion].x,
	            entity[PROPS$1.quaternion].y,
	            entity[PROPS$1.quaternion].z,
	            entity[PROPS$1.quaternion].w
	        );

	        // Init the entity

	        if (Entities.isNode && typeof Entities.Factories[entity[PROPS$1.netType]].initServer === 'function') {
	            Entities.Factories[entity[PROPS$1.netType]].initServer(entity);
	        }

	        if (!Entities.isNode && typeof Entities.Factories[entity[PROPS$1.netType]].initClient === 'function') {
	            Entities.Factories[entity[PROPS$1.netType]].initClient(entity);
	        }

	        // Set the world and the socket that belongs to this entity if any
	        if (Entities.isNode) {
	            entity.world = data.world;
	        }

	        // If there is a socket property add it to the entity
	        if (data.socket !== undefined) {
	            entity.socket = data.socket;
	        }

	        return entity;
	    }
	};

	var entities = Entities;

	var PROPS$2 = entities.PROPS;
	var Factory$1 = function (Game) {
	    Game.player.every(200, function () {
	        var position = {
	            x: Game.player[PROPS$2.position].x,
	            y: Game.player[PROPS$2.position].y + 15,
	            z: Game.player[PROPS$2.position].z + 12
	        };
	        Game.app.camera.position.lerp(position, 0.1);

	        Game.app.camera.lookAt(Game.player.body.position);
	    });

	    Game.player.every(100, function () {
	        if (Game.player && Game.player.socket) {
	            var pressedKeys = Game.keyboard.pressedKeys;
	            if (
	                pressedKeys.length > 0 &&
	                Game.keyboard.target === Game.canvas
	            ) {
	                Game.player.socket.emit('keyboard', pressedKeys);
	            }
	        }
	    });

	};

	/**
	 * This keyboard handler will be used both sides (server and client)
	 * to get the pressed keys by the user
	 */

	var modifiers = {
	    '⇧': 16, shift: 16,
	    '⌥': 18, alt: 18, option: 18,
	    '⌃': 17, ctrl: 17, control: 17,
	    '⌘': 91, command: 91
	};

	var special = {
	    backspace: 8, tab: 9, clear: 12,
	    enter: 13, 'return': 13,
	    esc: 27, escape: 27, space: 32,
	    left: 37, up: 38,
	    right: 39, down: 40,
	    del: 46, 'delete': 46,
	    home: 36, end: 35,
	    pageup: 33, pagedown: 34,
	    ',': 188, '.': 190, '/': 191,
	    '`': 192, '-': 189, '=': 187,
	    ';': 186, '\'': 222,
	    '[': 219, ']': 221, '\\': 220
	};

	var f = {
	    f1: 112,
	    f2: 113,
	    f3: 114,
	    f4: 115,
	    f5: 116,
	    f6: 117,
	    f7: 118,
	    f8: 119,
	    f9: 120,
	    f10: 121,
	    f11: 122,
	    f12: 123
	};

	var KeyboardFactory = function (element) {
	    var Keyboard = {
	        target: null,
	        pressedKeys: [],
	        code: function code(x) {
	            return special[x] ||
	                modifiers[x] ||
	                f[x] ||
	                x.toUpperCase().charCodeAt(0);
	        },
	        isPressed: function isPressed(x) {
	            return Keyboard.pressedKeys.indexOf(Keyboard.code(x)) !== -1;
	        },
	        pressKey: function pressKey(key) {
	            Keyboard.pressedKeys.push(Keyboard.code(key));
	        },
	        keyDownListener: function keyDownListener(event) {
	            Keyboard.target = event.target;
	            if (Keyboard.pressedKeys.indexOf(event.keyCode) === -1) {
	                Keyboard.pressedKeys.push(event.keyCode);
	            }
	        },
	        keyUpListener: function keyUpListener(event) {
	            var index = Keyboard.pressedKeys.indexOf(event.keyCode);
	            if (index !== -1) {
	                Keyboard.pressedKeys.splice(index, 1);
	            }
	        }
	    };

	    if (element !== undefined) {
	        var el = typeof element === 'string'
	            ? document.querySelectorAll(element)[0]
	            : element;

	        el.addEventListener
	            ? el.addEventListener('keydown', Keyboard.keyDownListener, false)
	            : el.attachEvent('onkeydown', Keyboard.keyDownListener);

	        el.addEventListener
	            ? el.addEventListener('keyup', Keyboard.keyUpListener, false)
	            : el.attachEvent('onkeyup', Keyboard.keyUpListener);
	    }

	    return Keyboard;
	};

	var keyboardFactory = KeyboardFactory;

	var Game$1 = {
	    config: config,
	    deltaTime: Date.now(),
	    is: {
	        ready: false,
	        connecting: false,
	        connected: false
	    },
	    ready: false,
	    quality: 0.8,
	    app: null,
	    children: {},
	    keyboard: null,
	    canvas: null,
	    initGame: function initGame() {return __async(function*(){
	        AppFactory(Game$1);
	        Game$1.setQuality();

	        entities.init();
	        Game$1.connection = ConnectionFactory(Game$1);
	        Game$1.connection.initSocket(Game$1.config.serverUrl);
	        Game$1.keyboard = keyboardFactory(document.body);

	        Game$1.update();
	        yield Game$1.getWorlds();
	        Game$1.is.ready = true;
	    }())},
	    update: function update() {
	        var dt = (Date.now() - Game$1.deltaTime) * .001;

	        for (var i in Game$1.children) {
	            Game$1.children[i].update(dt);
	        }

	        Game$1.deltaTime = Date.now();
	        Game$1.app.renderer.render(Game$1.app.scene, Game$1.app.camera);
	        requestAnimationFrame(function () { return Game$1.update(); });
	    },
	    setQuality: function setQuality(pixelRatio) {
	        if ( pixelRatio === void 0 ) pixelRatio = 0.8;

	        Game$1.quality = pixelRatio;
	        Game$1.app.renderer.setPixelRatio(window.devicePixelRatio * Game$1.quality);
	        Game$1.app.renderer.setSize(window.innerWidth, window.innerHeight);
	    },
	    addEntity: function addEntity(childEntity) {
	        Game$1.children[childEntity.id] = childEntity;
	        childEntity.parent = Game$1;
	        Game$1.app.scene.add(childEntity.body);
	    },
	    updateWorld: function updateWorld(world) {
	        for (var i in Game$1.children) {
	            if (world.children[i] === undefined) {
	                Game$1.children[i].destroy();
	            }
	        }

	        for (var i$1 in world.children) {
	            /**
	             * Entity must be undefined and must not be the player,
	             * we will handle the creation of the creation of the player entity
	             * when the connectServer promise resolve
	             */
	            if (Game$1.children[i$1] === undefined && Game$1.children[i$1].id !== Game$1.socket.id) {
	                var entity = entities.create(world.children[i$1]);
	                Game$1.addEntity(entity);
	            } else {
	                Object.assign(Game$1.children[i$1], world.children[i$1]);
	            }
	        }
	    },
	    setPlayerScripts: Factory$1,
	    connectServer: function connectServer() {return __async(function*(){
	        if (Game$1.is.ready && !Game$1.is.connecting && !Game$1.is.connected) {
	            Game$1.is.connecting = true;
	            var player = yield Game$1.connection.connectServer(Game$1.selectedWorld);
	            var entity = entities.create(player);
	            Game$1.addEntity(entity);
	            Game$1.player = entity;
	            Game$1.setPlayerScripts(Game$1);
	            Game$1.is.connected = true;
	            Game$1.is.connecting = false;
	        }
	    }())},
	    selectedWorld: null,
	    worlds: {},
	    getWorlds: function getWorlds() {return __async(function*(){
	        var worlds = yield Game$1.connection.getWorlds();
	        var selected = false;
	        for (var world in worlds) {
	            worlds[world].selected = false;
	            worlds[world].disabled = false;
	            if (
	                !selected &&
	                worlds[world].playerCount < worlds[world].maxPlayers
	            ) {
	                worlds[world].selected = true;
	                Game$1.selectedWorld = world;
	                selected = true;
	            }
	            if (worlds[world].playerCount >= worlds[world].maxPlayers) {
	                worlds[world].disabled = true;
	            }
	        }
	        Game$1.worlds = worlds;
	    }())},
	    selectWorld: function selectWorld(name) {
	        for (var world in Game$1.worlds) {
	            if (world === name) {
	                Game$1.worlds[world].selected = true;
	                Game$1.selectedWorld = world;
	            } else {
	                Game$1.worlds[world].selected = false;
	            }
	        }
	    }
	};

	var Page = {
	    autologin: true,
	    getOptions: function getOptions() {
	        var options = [];
	        for (var name in Game$1.worlds) {
	            var world = Game$1.worlds[name];
	            options.push(
	                v( 'option', { value: name, disabled: world.disabled, selected: world.selected }, "World ", name, " - (", world.playerCount, "/", world.maxPlayers, ")")
	            );
	        }
	        return options;
	    },
	    selectWorld: function selectWorld(e) {
	        Game$1.selectWorld(e.target.value);
	    },
	    play: function play() {return __async(function*(){
	        yield Game$1.connectServer();
	        v.routes.go('/game');
	    }())},
	    onupdate: function onupdate() {
	        if (Game$1.player) {
	            v.routes.go('/game');
	            return;
	        }

	        if (Page.autologin && Game$1.is.ready && !Game$1.is.connecting && !Game$1.is.connected) {
	            Page.play();
	        }
	    },
	    view: function view() {
	        return v( 'article', { onupdate: Page.onupdate },
	            v( Panel, { position: "center middle" }
	                /* {v.trust(logo)} */,
	                v( 'div', { 'data-flex': "" },
	                    v( Panel, { position: "inline", color: "white" },
	                        v( 'input', { placeholder: "Player name" }),
	                        v( 'select', { onchange: Page.selectWorld },
	                            Page.getOptions()
	                        ),
	                        v( 'button', {
	                            onclick: Page.play, 'data-background': "success", disabled: !Game$1.is.ready || Game$1.is.connecting, class: "w100" },
	                            Game$1.is.connecting ? 'Connecting...' : Game$1.is.ready ? 'Play' : 'Loading...'
	                        )
	                    ),
	                    v( Panel, { position: "inline", color: "white" }, "How to play"),
	                    v( Panel, { position: "inline", color: "white" }, "Best scores")
	                )
	            )
	        );
	    }
	};

	var Page$1 = {
	    onupdate: function onupdate() {
	        if (!Game$1.player) {
	            v.routes.go('/');
	        }
	    },
	    view: function view() {
	        return v( 'article', { onupdate: Page$1.onupdate },
	            v( Panel, { position: "center" }, "Welcome, this is the game ui.")
	        );
	    }
	};

	var Pages = {
	    Main: Main,
	    Home: Page,
	    Game: Page$1
	};

	var router = v.Router();
	router
	    .get('/', function () { return Pages.Home; })
	    .get('/game', function () { return Pages.Game; })
	;

	v.routes('#ui', router);

	if (v.is.browser) {
	    Game$1.initGame();
	    setInterval(function () { return v.update(); }, 100);
	}

	// Export what is needed for the backend
	var index = {Pages: Pages};

	return index;

})));
//# sourceMappingURL=index.min.js.map

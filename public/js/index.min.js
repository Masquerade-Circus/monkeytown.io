(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.App = factory());
}(this, (function () { 'use strict';

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	!function(){var e,n,o,t,i=[];function d(e,n,o,t,i){if("string"==typeof e){for(t in o={name:e,props:{},children:[],dom:null,isVnode:!0,nt:1,isSVG:"svg"===e},n){ o.props[t]=n[t]; }return d.utils.flat(arguments,2,o.children,!0),o}return "function"==typeof e?Object.assign({view:e,isComponent:!0},n):"object"==typeof e&&("function"==typeof e.view&&Object.assign(e,{isComponent:!0}),e.isComponent)?(i=e.view.apply(e,d.utils.flat(arguments,1,[])),Array.isArray(i)?i:[i]):void 0}function r(e,n){return 3===e.nodeType?{name:"#text",isVnode:!0,nodeValue:e.nodeValue,children:[],dom:e,nt:3}:1===e.nodeType?("svg"===(n={name:e.nodeName.toLowerCase(),props:{},children:[],dom:e,isVnode:!0,nodeValue:null,nt:1}).name&&(n.isSVG=!0),n.dom.events={},Array.prototype.map.call(e.attributes,function(e){n.props[e.nodeName]=e.nodeValue;}),Array.prototype.forEach.call(e.childNodes,function(e){var o=r(e);void 0!==o&&n.children.push(o);}),n):void 0}function s(e,n,o,t,i){if(1===e.nt&&(void 0!==e.props[n]&&e.props[n](e,o),"onremove"===n)){for(t=0,i=e.children.length;t<i;t++){ s(e.children[t],"onremove"); }e.children=[];}}function l(e){void 0!==e.currentTarget.events["on"+e.type]&&e.currentTarget.events["on"+e.type](e),d.update();}d.utils={flat:function(e,n,o,t,i){for(i=e.length,void 0===t&&(t=!1);n<i;n++){ Array.isArray(e[n])?o=d.utils.flat(e[n],0,o):(!1===t||void 0!==e[n]&&null!==e[n])&&o.push(e[n]); }return o}},(d.is={node:"undefined"==typeof window,mounted:!1,updating:!1}).browser=!d.is.node,d.trust=function(e){var n=document.createElement("div");return n.innerHTML=e.trim(),Array.prototype.map.call(n.childNodes,function (e){ return r(e); })},d.update=function(i){return "object"==typeof(i=d.utils.flat(arguments,0,[]))[0]&&i[0].isComponent&&(e=i.shift()),new Promise(function(r){if(!d.is.updating){if(d.is.updating=!0,i.unshift(e),o=d.apply(d,i),function e(n,o,t,i,r,u,p,a,m,c){if(0!==o.length){ for(r=o.length>t.length?o.length:t.length,a=0;a<r;a++){ if(p=t[a],void 0!==(u=o[a])){ if(void 0!==u.nt&&3!==u.nt){if(m=!d.is.mounted,i=i||u.isSVG,void 0===p){ s(u,"oninit"),u.dom=i?document.createElementNS("http://www.w3.org/2000/svg",u.name):document.createElement(u.name),u.dom.events={},n.appendChild(u.dom),p={children:[]},m=!0; }else if(u.name!==p.name){ s(u,"oninit"),u.dom=i?document.createElementNS("http://www.w3.org/2000/svg",u.name):document.createElement(u.name),u.dom.events={},s(p,"onremove"),n.replaceChild(u.dom,p.dom),m=!0; }else { for(c in u.dom=p.dom,p.props){ if(void 0===u.props[c]){if("function"==typeof p.props[c]){u.dom.removeEventListener(c.slice(2),l);continue}if(d.is.node||i||void 0===u.dom[c]){u.dom.removeAttribute(c);continue}u.dom[c]=null;} } }for(c in e(u.dom,u.children,p.children,i),u.props){ if((m||u.props[c]!==p.props[c])&&void 0!==u.props[c]){if("function"==typeof u.props[c]){switch(c){case"oninit":case"oncreate":case"onupdate":case"onremove":break;default:void 0===u.dom.events[c]&&(u.dom.events[c]=u.props[c],u.dom.addEventListener(c.slice(2),l));}continue}if(d.is.node||i||void 0===u.dom[c]){u.dom.setAttribute(c,u.props[c]);continue}u.dom[c]=u.props[c];} }d.is.mounted||m||(s(u,"oninit"),s(u,"oncreate")),s(u,m?"oncreate":"onupdate",p);}else { void 0===u.nt&&(o[a]=u={name:"#text",isVnode:!0,nodeValue:u,children:[],nt:3}),void 0===p?(u.dom=document.createTextNode(u.nodeValue),n.appendChild(u.dom)):1===p.nt?(u.dom=document.createTextNode(u.nodeValue),s(p,"onremove"),n.replaceChild(u.dom,p.dom)):(u.dom=p.dom,u.nodeValue!=p.nodeValue&&(u.dom.nodeValue=u.nodeValue)); } }else { void 0!==p&&(3===p.nt&&s(p,"onremove"),n.removeChild(p.dom)); } } }else { n.textContent=""; }}(t,o,n),n=o,d.is.updating=!1,d.is.mounted=!0,d.is.node){ return r(t.innerHTML); }r();}})},d.mount=function(e,o){return t=d.is.node?document.createElement("div"):"string"==typeof e?document.querySelectorAll(e)[0]:e,n=r(t).children,d.update.apply(this,d.utils.flat(arguments,1,[]))},d.use=function(e,n){return -1===i.indexOf(e)&&(e(d,n),i.push(e)),d},(d.is.node?commonjsGlobal:window).v=d;}();

	var plugin = function (v) {
	    var Request = function (baseUrl, options) {
	        if ( baseUrl === void 0 ) baseUrl = '';
	        if ( options === void 0 ) options = {};

	        var url = baseUrl.replace(/\/$/gi, '').trim(),
	            opts = Object.assign({
	                methods: ['get', 'post', 'put', 'patch', 'delete']
	            }, options),
	            parseUrl;

	        function serialize(obj, prefix) {
	            var e = encodeURIComponent;
	            return Object.keys(obj)
	                .map(function (p) {
	                    var k = prefix ? prefix + '[' + p + ']' : p;

	                    return typeof obj[p] === 'object'
	                        ? serialize(obj[p], k)
	                        : e(k) + '=' + e(obj[p]);
	                })
	                .join('&');
	        }

	        function request(method, url, data, options) {
	            if ( options === void 0 ) options = {};

	            var opts = Object.assign({
	                    method: method.toLowerCase(),
	                    headers: {
	                        'Accept': 'application/json',
	                        'Content-Type': 'application/json'
	                    }
	                }, request.options, options),
	                type = opts.headers.Accept;

	            if (data !== undefined) {
	                if (opts.method === 'get' && typeof data === 'object') {
	                    url += data = serialize(data);
	                }

	                if (opts.method !== 'get') {
	                    opts.body = JSON.stringify(data);
	                }
	            }

	            return fetch(parseUrl(url), opts)
	                .then(function (response) {
	                    if (!response.ok) {
	                        var err = new Error(response.statusText);
	                        err.response = response;
	                        throw err;
	                    }

	                    if (/text/gi.test(type)) {
	                        return response.text();
	                    }

	                    if (/json/gi.test(type)) {
	                        return response.json();
	                    }

	                    return response;
	                });
	        }
	        parseUrl = function (url) {
	            var u = /^https?/gi.test(url)
	                ? url
	                : (request.urls.base + '/' + url).trim().replace(/^\/\//gi, '/').trim();

	            if (
	                v.is.node &&
	                typeof request.urls.node === 'string'
	            ) {
	                request.urls.node = request.urls.node.replace(/\/$/gi, '').trim();

	                if (/^https?/gi.test(u) && typeof request.urls.api === 'string') {
	                    request.urls.api = request.urls.api.replace(/\/$/gi, '').trim();
	                    u = u.replace(request.urls.api, request.urls.node);
	                }

	                if (!/^https?/gi.test(u)) {
	                    u = request.urls.node + u;
	                }
	            }

	            return u;
	        };

	        request.new = function (baseUrl, options) {
	            return Request(baseUrl, options);
	        };

	        request.urls = {};
	        request.urls.api = undefined;
	        request.urls.node = undefined;
	        request.urls.base = url;
	        request.options = opts;

	        opts.methods.forEach(function (method) { return request[method] = function (url, data, options) { return request(method, url, data, options); }; }
	        );

	        return request;
	    };

	    v.request = Request();
	};

	function __async(g){return new Promise(function(s,j){function c(a,x){try{var r=g[x?"throw":"next"](a);}catch(e){j(e);return}r.done?s(r.value):Promise.resolve(r.value).then(c,d);}function d(e){c(e,1);}c();})}

	/**
	 * Handles the mix of single and array of middlewares
	 * @method parseMiddlewares
	 * @param  {Function|Array}         middlewares     // Middleware or array of middlewares
	 * @param  {Array}                  [array=[]]      // The array to store the final list of middlewares
	 * @return {Array}                                  // The final list of middlewares
	 */
	var parseMiddlewares = function (middlewares, array) {
	    if ( array === void 0 ) array = [];

	    if (typeof middlewares === 'function') {
	        array.push(middlewares);
	        return array;
	    }

	    var i = 0, l = middlewares.length;
	    for (; i < l; i++) {
	        if (Array.isArray(middlewares[i])) {
	            parseMiddlewares(middlewares[i], array);
	            continue;
	        }

	        array.push(middlewares[i]);
	    }
	    return array;
	};

	/**
	 * @description Adds a path to a router
	 * @method addPath
	 * @param  {Router} router              The router in which to add the path
	 * @param  {String} method              The method that will handle this path
	 * @param  {Array} args                The mixed params (String|Function|Array)
	 * @returns {Router}                    The router
	 */
	var addPath = function (router, method, args) {
	    var path, middlewares;

	    // Get the first argument
	    if (typeof args[0] === 'string') {
	        path = args.shift();
	    }

	    // If the seccond argument is a function and has paths
	    // and regexpList properties then
	    // Treat it as a subrouter
	    if (
	        typeof args[0] === 'function' &&
	        args[0].paths &&
	        args[0].regexpList
	    ) {
	        var subrouter = args.shift(),
	            i = 0,
	            l = subrouter.paths.length;

	        // For each path of the subrouter
	        for (; i < l; i++) {
	            var submiddlewares = subrouter.paths[i].middlewares;
	            var submethod = subrouter.paths[i].method;
	            var subpath = subrouter.paths[i].path;

	            // If there is a path add it as prefix to the subpath
	            if (path) {
	                subpath = path + (subpath || '*');
	            }

	            // If there is a subpath set it as the first element
	            // on the submiddlewares array
	            if (subpath) {
	                submiddlewares.unshift(subpath);
	            }

	            // Add the path to the router
	            router = addPath(router, submethod, submiddlewares);
	        }
	    }

	    // Parse middlwares to handle mixed arrays of middlwares and sequenced middlwares
	    middlewares = parseMiddlewares(args);

	    // Add the path only if there are middlewares passed
	    if (middlewares.length > 0) {
	        // If the path wasn't set before, set the regexp and params list
	        if (path && router.regexpList[path] === undefined) {
	            // Remove the last slash
	            path = path.replace(/\/(\?.*)?$/gi, '$1');

	            // Find the express like params
	            var params = path.match(/:(\w+)?/gi) || [];

	            // Set the names of the params found
	            for (var i$1 in params) {
	                params[i$1] = params[i$1].slice(1);
	            }

	            var regexpPath = path
	                // Catch params
	                .replace(/:(\w+)/gi, '([^\\s\\/|\\?]+)')
	                // To set to any url with the path as prefix
	                .replace(/\*/g, '.*')
	                // Remove the last slash
	                .replace(/\/(\?.*)?$/gi, '$1');

	            // Set the object to the path
	            router.regexpList[path] = {
	                regexp: new RegExp('^' + regexpPath + '/?(\\?.*)?$', 'gi'),
	                params: params
	            };
	        }

	        // Add the path to the paths list
	        router.paths.push({
	            method: method,
	            path: path,
	            middlewares: middlewares
	        });
	    }

	    return router;
	};

	var RouterFactory = function () {
	    /**
	     * new Rotuer
	     * @param  {String}    url     The path to call
	     * @return {Any}           The final response
	     */
	    var Router = function (url) {
	    if ( url === void 0 ) url = '/';
	return __async(function*(){
	        var method = 'get',
	            params = {},
	            middlewares = [],
	            response,
	            i = 0,
	            l = Router.paths.length;

	        Router.url = url;

	        for (; i < l; i++) {
	            var path = Router.paths[i];
	            if (method !== path.method && path.method !== 'use') {
	                continue;
	            }

	            if ((path.method === 'use' || method === path.method) && path.path === undefined) {
	                parseMiddlewares(path.middlewares, middlewares);
	                continue;
	            }

	            var reg = Router.regexpList[path.path];
	            var matches = reg.regexp.exec(url);
	            reg.regexp.lastIndex = -1;
	            if (Array.isArray(matches)) {
	                matches.shift();
	                var regparams = reg.params;
	                var l$1 = regparams.length;
	                for (; l$1--;) {
	                    if (params[regparams[l$1]] === undefined) {
	                        params[regparams[l$1]] = matches[l$1];
	                    }
	                }
	                parseMiddlewares(path.middlewares, middlewares);
	            }
	        }

	        Router.params = params;

	        if (middlewares.length > 0) {
	            var i$1 = 0, l$2 = middlewares.length;
	            // call sequentially every middleware
	            for (; i$1 < l$2; i$1++) {
	                response = yield middlewares[i$1](params);
	                // If there is a response
	                // break the for block
	                if (response) {
	                    return response;
	                }
	            }
	        }

	        if (Router.throwNotFound) {
	            // If no response was sent to the client throw an error
	            throw new Error(("The url " + url + " requested wasn't found"));
	        }
	    }())};

	    Router.url = '/';
	    Router.params = {};
	    Router.throwNotFound = true;

	    /**
	     * Where to store the paths and its middlewares
	     * @type {Object}
	     */
	    Router.paths = [];

	    /**
	     * Where to store the regexp and params list for the paths
	     * @type {[type]}
	     */
	    Router.regexpList = {};

	    // For each accepted method, add the method to the router
	    Router.get = function () {
	        return addPath(Router, 'get', v.utils.flat(arguments, 0, []));
	    };
	    Router.use = function () {
	        return addPath(Router, 'use', v.utils.flat(arguments, 0, []));
	    };

	    /**
	     * Return the new router
	     * @type {Router}
	     */
	    return Router;
	};


	var plugin$1 = function (v) {
	    var mainRouter;
	    var RoutesContainer;
	    function runRoute(parentComponent, url, args) {
	        return mainRouter(url)
	            .then(function (response) {
	                if (typeof response !== 'object') {
	                    throw new Error('v.router.component.required');
	                }

	                if (!response.isComponent && typeof response.view === 'function') {
	                    Object.assign(response, {isComponent: true});
	                }

	                if (!response.isComponent) {
	                    throw new Error('v.router.component.required');
	                }

	                if (parentComponent) {
	                    args.unshift(v(response, args));
	                    response = parentComponent;
	                }

	                args.unshift(response);

	                if (v.is.node || !v.is.mounted) {
	                    args.unshift(RoutesContainer);
	                    return v.mount.apply(v, args);
	                }

	                return v.update.apply(v, args);
	            });
	    }
	    v.routes = function (elementContainer, router) {
	        if (elementContainer && router) {
	            mainRouter = router;
	            RoutesContainer = elementContainer;
	            // Activate the use of the router
	            if (v.is.browser) {
	                function onPopStateGoToRoute() {
	                    v.routes.go(document.location.pathname);
	                }
	                window.addEventListener('popstate', onPopStateGoToRoute, false);
	                onPopStateGoToRoute();
	            }
	        }
	    };

	    v.routes.get = function () {
	        var routes = [];
	        mainRouter.paths.forEach(function (path) {
	            if (path.method === 'get') {
	                routes.push(path.path === '' ? '/' : path.path);
	            }
	        });
	        return routes;
	    };

	    v.routes.current = '/';
	    v.routes.params = {};

	    v.routes.go = function () {
	        var args = v.utils.flat(arguments, 0, []);
	        var parentComponent;
	        var url;

	        if (typeof args[0] === 'object') {
	            if (!args[0].isComponent && typeof args[0].view === 'function') {
	                args[0] = Object.assign(args[0], {isComponent: true});
	            }

	            if (args[0].isComponent) {
	                parentComponent = args.shift();
	            }
	        }

	        if (typeof args[0] === 'string') {
	            url = args.shift();
	        }

	        if (!url) {
	            throw new Error('v.router.url.required');
	        }

	        if (v.is.browser) {
	            window.history.pushState({}, '', url);
	        }

	        return runRoute(parentComponent, url, args);
	    };

	    v.Router = RouterFactory;
	};

	v
	    .use(plugin$1)
	    .use(plugin)
	;

	var displayName = "MonkeyTown.io";
	var description = "Build your monkey home and survive";
	var version = "0.0.1";

	var Main = {
	    title: displayName,
	    version: version,
	    description: description,
	    id: (0 | Math.random() * 6.04e7).toString(36), // change this to version when publish
	    view: function view() {
	        var children = [], len = arguments.length;
	        while ( len-- ) children[ len ] = arguments[ len ];

	        var view = v( 'html', { lang: "en" },
	            v( 'head', null,
	                v( 'title', null, Main.title ),
	                v( 'meta', { charset: "utf-8" }),
	                v( 'meta', { name: "description", content: Main.description }),
	                v( 'meta', { 'http-equiv': "x-UA-Compatible", content: "IE=edge" }),
	                v( 'meta', { name: "viewport", content: "width=device-width, initial-scale=1, maximum-scale=5, minimal-ui" }),
	                v( 'link', { href: ("/css/main.css?v=" + (Main.id)), rel: "stylesheet" }),
	                v( 'link', { rel: "shortcut icon", href: "/imgs/favicon.ico" })
	            ),
	            v( 'body', null,
	                v( 'div', { id: "ui" },
	                    children,
	                    v( 'script', { src: ("/js/socket.io.js?v=" + (Main.id)) }),
	                    v( 'script', { src: ("/js/three.min.js?v=" + (Main.id)) }),
	                    v( 'script', { src: ("/js/index.min.js?v=" + (Main.id)) })
	                )
	            )
	        );

	        return view;
	    }
	};

	var Panel = v(function (props) {
	    var children = [], len = arguments.length - 1;
	    while ( len-- > 0 ) children[ len ] = arguments[ len + 1 ];

	    return v( 'section', { 'data-panel': props.position, 'data-background': props.color },
	        v( 'nav', null, props.title ),
	        v( 'div', null, children )
	    );
	});

	var config = {
	    dev: true,
	    localUrl: 'http://localhost:3000',
	    serverUrl: 'http://localhost:3000'
	};

	var AppFactory = function (Game) {
	    Game.app = {};

	    Game.app.scene = new THREE.Scene();
	    Game.app.scene.background = new THREE.Color(0xf2f7ff);
	    // Game.app.scene.fog = new THREE.Fog(0xf2f7ff, 1, 200);

	    Game.app.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
	    Game.app.camera.position.set(0, 15, 12);
	    Game.app.camera.lookAt(new THREE.Vector3(0, 0, 0));
	    Game.app.scene.add(Game.app.camera);

	    Game.app.mixer = new THREE.AnimationMixer(Game.app.scene);

	    Game.app.listener = new THREE.AudioListener();
	    Game.app.camera.add(Game.app.listener);

	    Game.app.renderer = new THREE.WebGLRenderer({ antialias: true });
	    Game.app.renderer.setPixelRatio(window.devicePixelRatio);
	    Game.app.renderer.setSize(window.innerWidth, window.innerHeight);
	    Game.app.renderer.shadowMap.enabled = true;
	    Game.app.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	    Game.canvas = Game.app.renderer.domElement;

	    document.body.appendChild(Game.canvas);
	    Game.canvas.setAttribute('tabindex', '0');
	    Game.canvas.setAttribute('id', 'game-canvas');

	    window.addEventListener('resize', function () {
	        Game.app.camera.aspect = window.innerWidth / window.innerHeight;
	        Game.app.camera.updateProjectionMatrix();
	        Game.app.renderer.setSize(window.innerWidth, window.innerHeight);
	    });


	    Game.app.light = new THREE.DirectionalLight(0xffffff, 0.9);
	    Game.app.light.position.set(30, 60, 50);
	    Game.app.light.position.multiplyScalar(2);

	    Game.app.light.shadow.camera.left = -162;
	    Game.app.light.shadow.camera.right = 162;
	    Game.app.light.shadow.camera.top = 162;
	    Game.app.light.shadow.camera.bottom = -162;
	    Game.app.light.shadow.mapSize.width = 2048;
	    Game.app.light.shadow.mapSize.height = 2048;

	    Game.app.light.castShadow = true;
	    Game.app.scene.add(Game.app.light);

	    Game.app.ambientlight = new THREE.AmbientLight(0x999999);
	    Game.app.scene.add(Game.app.ambientlight);

	    Game.app.hemiLight = new THREE.HemisphereLight(0xffffff, 0x00ff00, 0.6);
	    Game.app.scene.add(Game.app.hemiLight);

	    var textureLoader = new THREE.TextureLoader();
	    var groundtexture = textureLoader.load("imgs/grass.gif");
	    var groundmaterial = new THREE.MeshPhongMaterial({
	        color: 0x999999,
	        map: groundtexture
	    });
	    groundtexture.anisotropy = 1;
	    groundtexture.wrapS = groundtexture.wrapT = THREE.RepeatWrapping;
	    groundtexture.repeat.set(512, 512);
	    Game.app.ground = new THREE.Mesh(
	        new THREE.PlaneBufferGeometry(300, 300),
	        groundmaterial
	    );
	    Game.app.ground.rotation.x = -(Math.PI / 2);
	    Game.app.ground.castShadow = false;
	    Game.app.ground.receiveShadow = true;
	    Game.app.ground.position.set(0, -1, 0);
	    Game.app.ground.scale.set(15, 15, 15);
	    Game.app.scene.add(Game.app.ground);

	    var limits = new THREE.Mesh(
	        new THREE.RingBufferGeometry(145, 150, 4),
	        new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide })
	    );
	    limits.position.set(0, 0.8, 0);
	    limits.castShadow = true;
	    limits.receiveShadow = true;
	    limits.rotation.x = -Math.PI / 2;
	    limits.rotation.z = -Math.PI / 4;
	    Game.app.scene.add(limits);
	};

	var ConnectionFactory = function (Game) {
	    var Connection = {
	        initSocket: function initSocket(url) {
	            if (Game.socket !== undefined) {
	                Game.socket.disconnect();
	                Game.socket = undefined;
	            }

	            Game.socket = io(url);

	            /**
	             * As we will destroy the player when socket disconnects
	             * with this we will reload the browser page if the user recconnects
	             */
	            Game.socket.on('reconnect', function () { return window.location.href = window.location.href; });

	            // Custom game events
	            Game.socket.on('world', function (data) { return Game.updateWorld(data); });
	        },
	        connectServer: function connectServer(world) {
	            if ( world === void 0 ) world = 'Alpha';

	            return new Promise(function (resolve) {
	                Game.socket.emit('connectServer', world, function (err, entity) {
	                    if (err) {
	                        console.error(err);
	                        return;
	                    }
	                    entity.socket = Game.socket;
	                    resolve(entity);
	                });
	            });
	        },
	        getWorlds: function () { return new Promise(function (resolve) { return Game.socket.emit('getWorlds', resolve); }); }
	    };
	    return Connection;
	};

	var KeyboardScriptFactory = function (Game) {
	    var raycaster = new THREE.Raycaster();
	    var mouse = new THREE.Vector2();
	    var intersects;

	    return function () {
	        var mouseData = {
	            b: Game.keyboard.mouse.b,
	            d: Game.keyboard.mouse.d
	        };

	        if (
	            mouse.x !== Game.keyboard.mouse.x || mouse.y !== Game.keyboard.mouse.y // Mouse moved
	            || mouseData.b.length > 0 // Button pressed
	            || mouseData.d !== 0 // Mousewheel event
	        ) {
	            mouse.x = Game.keyboard.mouse.x;
	            mouse.y = Game.keyboard.mouse.y;
	            mouseData.p = false;
	            raycaster.setFromCamera(mouse, Game.app.camera);
	            intersects = raycaster.intersectObjects([Game.app.ground]);
	            if (intersects.length === 1) {
	                mouseData.p = {
	                    x: intersects[0].point.x,
	                    y: intersects[0].point.y,
	                    z: intersects[0].point.z
	                };
	            }
	            Game.player.socket.emit('mouse', Game.fixedProps(mouseData));
	        }

	        if (
	            Game.keyboard.pressedKeys.length > 0 &&
	            Game.keyboard.target === Game.canvas
	        ) {
	            Game.player.socket.emit('keyboard', Game.keyboard.pressedKeys);
	        }
	    };
	};

	var TinyAnimate = createCommonjsModule(function (module, exports) {
	/**
	 * TinyAnimate
	 *  version 0.3.0
	 *
	 * Source:  https://github.com/branneman/TinyAnimate
	 * Author:  Bran van der Meer <branmovic@gmail.com> (http://bran.name/)
	 * License: MIT
	 *
	 * Functions:
	 *  TinyAnimate.animate(from, to, duration, update, easing, done)
	 *  TinyAnimate.animateCSS(element, property, unit, from, to, duration, easing, done)
	 *  TinyAnimate.cancel(animation)
	 *
	 * Parameters:
	 *  element   HTMLElement        A dom node
	 *  property  string             Property name, as available in element.style, i.e. 'borderRadius', not 'border-radius'
	 *  unit      string             Property unit, like 'px'
	 *  from      int                Property value to animate from
	 *  to        int                Property value to animate to
	 *  duration  int                Duration in milliseconds
	 *  update    function           Function to implement updating the DOM, get's called with a value between `from` and `to`
	 *  easing    string | function  Optional: A string when the easing function is available in TinyAnimate.easings,
	 *                                or a function with the signature: function(t, b, c, d) {...}
	 *  done      function           Optional: To be executed when the animation has completed.
	 *
	 * Returns:
	 *  animation object             Animation object that can be canceled.
	 */

	/**
	 * Universal Module Dance
	 *  config: CommonJS Strict, exports Global, supports circular dependencies
	 *  https://github.com/umdjs/umd/
	 */
	(function(root, factory) {
	    {
	        factory(exports);
	    }
	}(commonjsGlobal, function(exports) {

	    /**
	     * TinyAnimate.animate()
	     */
	    exports.animate = function(from, to, duration, update, easing, done) {

	        // Early bail out if called incorrectly
	        if (typeof from !== 'number' ||
	            typeof to !== 'number' ||
	            typeof duration !== 'number' ||
	            typeof update !== 'function')
	            { return; }

	        // Determine easing
	        if (typeof easing === 'string' && easings[easing]) {
	            easing = easings[easing];
	        }
	        if (typeof easing !== 'function') {
	            easing = easings.linear;
	        }

	        // Create mock done() function if necessary
	        if (typeof done !== 'function') {
	            done = function() {};
	        }

	        // Pick implementation (requestAnimationFrame | setTimeout)
	        var rAF = window.requestAnimationFrame || function(callback) {
	            window.setTimeout(callback, 1000 / 60);
	        };

	        // Animation loop
	        var canceled = false;
	        var change = to - from;
	        function loop(timestamp) {
	            if (canceled) {
	                return;
	            }
	            var time = (timestamp || +new Date()) - start;
	            if (time >= 0) {
	                update(easing(time, from, change, duration));
	            }
	            if (time >= 0 && time >= duration) {
	                update(to);
	                done();
	            } else {
	                rAF(loop);
	            }
	        }
	        update(from);

	        // Start animation loop
	        var start = window.performance && window.performance.now ? window.performance.now() : +new Date();

	        rAF(loop);

	        return {
	            cancel: function() {
	                canceled = true;
	            }
	        };
	    };

	    /**
	     * TinyAnimate.animateCSS()
	     *  Shortcut method for animating css properties
	     */
	    exports.animateCSS = function(element, property, unit, from, to, duration, easing, done) {

	        var update = function(value) {
	            element.style[property] = value + unit;
	        };
	        return exports.animate(from, to, duration, update, easing, done);
	    };

	    /**
	     * TinyAnimate.cancel()
	     *  Method for canceling animations
	     */
	    exports.cancel = function(animation) {
	        if (!animation) {
	            return;
	        }
	        animation.cancel();
	    };

	    /**
	     * TinyAnimate.easings
	     *  Adapted from jQuery Easing
	     */
	    var easings = exports.easings = {};
	    easings.linear = function(t, b, c, d) {
	        return c * t / d + b;
	    };
	    easings.easeInQuad = function(t, b, c, d) {
	        return c * (t /= d) * t + b;
	    };
	    easings.easeOutQuad = function(t, b, c, d) {
	        return -c * (t /= d) * (t - 2) + b;
	    };
	    easings.easeInOutQuad = function(t, b, c, d) {
	        if ((t /= d / 2) < 1) { return c / 2 * t * t + b; }
	        return -c / 2 * ((--t) * (t - 2) - 1) + b;
	    };
	    easings.easeInCubic = function(t, b, c, d) {
	        return c * (t /= d) * t * t + b;
	    };
	    easings.easeOutCubic = function(t, b, c, d) {
	        return c * ((t = t / d - 1) * t * t + 1) + b;
	    };
	    easings.easeInOutCubic = function(t, b, c, d) {
	        if ((t /= d / 2) < 1) { return c / 2 * t * t * t + b; }
	        return c / 2 * ((t -= 2) * t * t + 2) + b;
	    };
	    easings.easeInQuart = function(t, b, c, d) {
	        return c * (t /= d) * t * t * t + b;
	    };
	    easings.easeOutQuart = function(t, b, c, d) {
	        return -c * ((t = t / d - 1) * t * t * t - 1) + b;
	    };
	    easings.easeInOutQuart = function(t, b, c, d) {
	        if ((t /= d / 2) < 1) { return c / 2 * t * t * t * t + b; }
	        return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
	    };
	    easings.easeInQuint = function(t, b, c, d) {
	        return c * (t /= d) * t * t * t * t + b;
	    };
	    easings.easeOutQuint = function(t, b, c, d) {
	        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
	    };
	    easings.easeInOutQuint = function(t, b, c, d) {
	        if ((t /= d / 2) < 1) { return c / 2 * t * t * t * t * t + b; }
	        return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
	    };
	    easings.easeInSine = function(t, b, c, d) {
	        return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
	    };
	    easings.easeOutSine = function(t, b, c, d) {
	        return c * Math.sin(t / d * (Math.PI / 2)) + b;
	    };
	    easings.easeInOutSine = function(t, b, c, d) {
	        return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
	    };
	    easings.easeInExpo = function(t, b, c, d) {
	        return (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
	    };
	    easings.easeOutExpo = function(t, b, c, d) {
	        return (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
	    };
	    easings.easeInOutExpo = function(t, b, c, d) {
	        if (t == 0) { return b; }
	        if (t == d) { return b + c; }
	        if ((t /= d / 2) < 1) { return c / 2 * Math.pow(2, 10 * (t - 1)) + b; }
	        return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
	    };
	    easings.easeInCirc = function(t, b, c, d) {
	        return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
	    };
	    easings.easeOutCirc = function(t, b, c, d) {
	        return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
	    };
	    easings.easeInOutCirc = function(t, b, c, d) {
	        if ((t /= d / 2) < 1) { return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b; }
	        return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
	    };
	    easings.easeInElastic = function(t, b, c, d) {
	        var p = 0;
	        var a = c;
	        if (t == 0) { return b; }
	        if ((t /= d) == 1) { return b + c; }
	        if (!p) { p = d * .3; }
	        if (a < Math.abs(c)) {
	            a = c;
	            var s = p / 4;
	        }
	        else { var s = p / (2 * Math.PI) * Math.asin(c / a); }
	        return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
	    };
	    easings.easeOutElastic = function(t, b, c, d) {
	        var p = 0;
	        var a = c;
	        if (t == 0) { return b; }
	        if ((t /= d) == 1) { return b + c; }
	        if (!p) { p = d * .3; }
	        if (a < Math.abs(c)) {
	            a = c;
	            var s = p / 4;
	        }
	        else { var s = p / (2 * Math.PI) * Math.asin(c / a); }
	        return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
	    };
	    easings.easeInOutElastic = function(t, b, c, d) {
	        var p = 0;
	        var a = c;
	        if (t == 0) { return b; }
	        if ((t /= d / 2) == 2) { return b + c; }
	        if (!p) { p = d * (.3 * 1.5); }
	        if (a < Math.abs(c)) {
	            a = c;
	            var s = p / 4;
	        }
	        else { var s = p / (2 * Math.PI) * Math.asin(c / a); }
	        if (t < 1) { return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b; }
	        return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b;
	    };
	    easings.easeInBack = function(t, b, c, d, s) {
	        if (s == undefined) { s = 1.70158; }
	        return c * (t /= d) * t * ((s + 1) * t - s) + b;
	    };
	    easings.easeOutBack = function(t, b, c, d, s) {
	        if (s == undefined) { s = 1.70158; }
	        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
	    };
	    easings.easeInOutBack = function(t, b, c, d, s) {
	        if (s == undefined) { s = 1.70158; }
	        if ((t /= d / 2) < 1) { return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b; }
	        return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
	    };
	    easings.easeInBounce = function(t, b, c, d) {
	        return c - easings.easeOutBounce(d - t, 0, c, d) + b;
	    };
	    easings.easeOutBounce = function(t, b, c, d) {
	        if ((t /= d) < (1 / 2.75)) {
	            return c * (7.5625 * t * t) + b;
	        } else if (t < (2 / 2.75)) {
	            return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;
	        } else if (t < (2.5 / 2.75)) {
	            return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;
	        } else {
	            return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;
	        }
	    };
	    easings.easeInOutBounce = function(t, b, c, d) {
	        if (t < d / 2) { return easings.easeInBounce(t * 2, 0, c, d) * .5 + b; }
	        return easings.easeOutBounce(t * 2 - d, 0, c, d) * .5 + c * .5 + b;
	    };

	}));
	});

	var circle = function (rad, color, segments) {
	    if ( segments === void 0 ) segments = 32;

	    var geometry = new THREE.CircleBufferGeometry(rad, segments);
	    var material = new THREE.MeshStandardMaterial({ color: color, side: THREE.DoubleSide });
	    var circle = new THREE.Mesh(geometry, material);
	    circle.receiveShadow = true;
	    return circle;
	};

	var MonkeyFactory = function () {
	    var hand = circle(0.8, 0x542207);
	    hand.position.set(-1.5, -1.5, -0.2);
	    var r = circle(0.74, 0xefcfa6);
	    r.position.set(0, 0, 0.1);
	    hand.add(r);
	    hand.castShadow = true;
	    hand.receiveShadow = true;

	    var hand2 = circle(0.8, 0x542207);
	    hand2.position.set(1.5, -1.5, -0.2);
	    var r2 = circle(0.74, 0xefcfa6);
	    r2.position.set(0, 0, 0.1);
	    hand2.add(r2);
	    hand2.castShadow = true;
	    hand2.receiveShadow = true;

	    var ear = circle(0.6, 0x542207);
	    ear.position.set(-2.1, 0, -0.2);
	    var ei = circle(0.4, 0xe0ac7d);
	    ei.position.set(0.1, -0.1, 0.1);
	    ear.add(ei);
	    ear.castShadow = true;
	    ear.receiveShadow = true;

	    var ear2 = circle(0.6, 0x542207);
	    ear2.position.set(2.1, 0, -0.2);
	    var ei2 = circle(0.4, 0xe0ac7d);
	    ei2.position.set(-0.1, -0.1, 0.1);
	    ear2.add(ei2);
	    ear2.castShadow = true;
	    ear2.receiveShadow = true;

	    var monkey = circle(2, 0x542207);

	    var mouth = circle(1, 0xefcfa6);
	    mouth.position.set(0, -1, 0.1);
	    var n = circle(0.1, 0x000000);
	    n.position.set(-0.15, -0.15, 0.1);
	    mouth.add(n);
	    var n2 = circle(0.1, 0x000000);
	    n2.position.set(0.15, -0.15, 0.1);
	    mouth.add(n2);

	    var eye1 = circle(1, 0xefcfa6);
	    eye1.position.set(-0.9, -0.1, 0.1);
	    var p = circle(0.3, 0x000000);
	    p.position.set(0, -0.2, 0.1);
	    eye1.add(p);
	    var pl = circle(0.1, 0xffffff);
	    pl.position.set(0, -0.1, 0.1);
	    p.add(pl);

	    var eye2 = circle(1, 0xefcfa6);
	    eye2.position.set(0.9, -0.1, 0.1);
	    var p2 = circle(0.3, 0x000000);
	    p2.position.set(0, -0.2, 0.1);
	    eye2.add(p2);
	    var pl2 = circle(0.1, 0xffffff);
	    pl2.position.set(0, -0.1, 0.1);
	    p2.add(pl2);

	    monkey.add(hand);
	    monkey.add(hand2);
	    monkey.add(ear2);
	    monkey.add(ear);
	    monkey.add(eye1);
	    monkey.add(eye2);
	    monkey.add(mouth);

	    monkey.rotation.x = -(Math.PI / 2);
	    monkey.scale.set(0.5, 0.5, 0.5);

	    monkey.castShadow = true;
	    monkey.receiveShadow = true;

	    var object = new THREE.Object3D();
	    object.add(monkey);
	    return object;
	};

	var Factory = function () {

	    return {
	        Model: MonkeyFactory(),
	        initServer: function initServer(entity) {

	        },
	        initClient: function initClient(entity) {
	            var Model = entity.body.getObjectByName('Model');
	            var Fighting = {
	                animating: false,
	                animate: function animate() {
	                    if (!Fighting.animating) {
	                        Fighting.animating = true;
	                        TinyAnimate.animate(0, Math.PI / 2, 100, Fighting.update, 'easeIn', function () {
	                            TinyAnimate.animate(Math.PI / 2, 0, 400, Fighting.update, 'easeOut', function () {
	                                Fighting.animating = false;
	                            });
	                        });
	                    }
	                },
	                update: function update(rad) {
	                    Model.rotation.y = rad;
	                }
	            };

	            entity.addScript('tick', function (dt) {
	                if (entity[config$1.PROPS.Status] === config$1.STATUS.Fighting) {
	                    Fighting.animate();
	                }
	            });
	        }
	    };
	};

	var playerEntityFactory = Factory;

	var AppleFactory = function () {
	    var applesGeometry = new THREE.Geometry();
	    var geometry = new THREE.SphereGeometry(0.3, 16, 16);

	    geometry.translate(0, 1.7, 0);
	    applesGeometry.merge(geometry);

	    geometry.translate(-1, -1, -1);
	    applesGeometry.merge(geometry);

	    geometry.translate(0, 0, 2);
	    applesGeometry.merge(geometry);

	    geometry.translate(2, 0, 0);
	    applesGeometry.merge(geometry);

	    geometry.translate(0, 0, -2);
	    applesGeometry.merge(geometry);

	    var buffGeometry = new THREE.BufferGeometry().fromGeometry(applesGeometry);
	    var material = new THREE.MeshStandardMaterial({ color: 0xff1122, side: THREE.DoubleSide, roughness: 1, metalness: 0 });
	    var apples = new THREE.Mesh(buffGeometry, material);
	    apples.position.set(0, 0, 0);
	    return apples;
	};

	var TreeFactory = function () {
	    var cylinder = new THREE.Mesh(
	        new THREE.CylinderBufferGeometry(0.2, 0.5, 2, 32),
	        new THREE.MeshStandardMaterial({color: 0x542207, metalness: 0, roughness: 1})
	    );

	    var ico = new THREE.Mesh(
	        new THREE.IcosahedronBufferGeometry(2),
	        new THREE.MeshStandardMaterial({color: 0x087f23, metalness: 0, roughness: 1})
	    );
	    ico.position.set(0, 2, 0);
	    ico.castShadow = true;
	    ico.receiveShadow = true;
	    ico.name = 'top';

	    cylinder.add(ico);
	    ico.add(AppleFactory());
	    cylinder.castShadow = true;
	    cylinder.receiveShadow = true;

	    return cylinder;
	};
	var Factory$1 = function () {
	    return {
	        Model: TreeFactory(),
	        initServer: function initServer(entity) {
	            var Config = config$1;
	            entity.addScript('fight', function () {
	                entity[Config.PROPS.Status] = Config.STATUS.Fighting;
	                setTimeout(function () { return entity[Config.PROPS.Status] = Config.STATUS.Static; }, 400);
	            });
	        },
	        initClient: function initClient(entity) {
	            var Config = config$1;
	            var TreeModel = entity.body.getObjectByName('Model');
	            var Model = TreeModel.getObjectByName('top');
	            var Fighting = {
	                animating: false,
	                animate: function animate() {
	                    if (!Fighting.animating) {
	                        Fighting.animating = true;
	                        TinyAnimate.animate(0, -0.5, 100, Fighting.update, 'easeIn', function () {
	                            TinyAnimate.animate(-0.5, 0, 400, Fighting.update, 'easeOut', function () {
	                                Fighting.animating = false;
	                            });
	                        });
	                    }
	                },
	                update: function update(pos) {
	                    Model.position.z = pos;
	                }
	            };

	            entity.addScript('tick', function (dt) {
	                if (entity[Config.PROPS.Status] === Config.STATUS.Fighting) {
	                    Fighting.animate();
	                }
	            });
	        }
	    };
	};

	var treeEntityFactory = Factory$1;

	var RockFactory = function (Type) {
	    var data;
	    switch (Type) {
	        case 'gold':
	            data = {color: 0xFFD700};
	            break;
	        case 'silver':
	            data = {color: 0xCBCDCD};
	            break;
	        case 'iron':
	            data = {color: 0x828383};
	            break;
	        case 'stone':
	            data = {color: 0x535454};
	            break;
	    }

	    var ico = new THREE.Mesh(
	        new THREE.IcosahedronBufferGeometry(2),
	        new THREE.MeshStandardMaterial(data)
	    );
	    ico.position.set(0, -0.5, 0);
	    ico.castShadow = true;
	    ico.receiveShadow = true;
	    ico.rotation.y = -Math.PI / Math.random() * 2;

	    return ico;
	};

	var Factory$2 = function (Type) {
	    if ( Type === void 0 ) Type = 'stone';

	    return function () {

	    return {
	        Model: RockFactory(Type),
	        initServer: function initServer(entity) {
	            var Config = config$1;
	            entity.addScript('fight', function () {
	                entity[Config.PROPS.Status] = Config.STATUS.Fighting;
	                setTimeout(function () { return entity[Config.PROPS.Status] = Config.STATUS.Static; }, 400);
	            });
	        },
	        initClient: function initClient(entity) {
	            var Config = config$1;
	            var Model = entity.body.getObjectByName('Model');
	            var Fighting = {
	                animating: false,
	                animate: function animate() {
	                    if (!Fighting.animating) {
	                        Fighting.animating = true;
	                        TinyAnimate.animate(0, -0.5, 100, Fighting.update, 'easeIn', function () {
	                            TinyAnimate.animate(-0.5, 0, 400, Fighting.update, 'easeOut', function () {
	                                Fighting.animating = false;
	                            });
	                        });
	                    }
	                },
	                update: function update(pos) {
	                    Model.position.z = pos;
	                }
	            };

	            entity.addScript('tick', function (dt) {
	                if (entity[Config.PROPS.Status] === Config.STATUS.Fighting) {
	                    Fighting.animate();
	                }
	            });
	        }
	    };
	};
	};

	var rockEntityFactory = Factory$2;

	var AppleFactory$1 = function () {
	    var applesGeometry = new THREE.Geometry();
	    var geometry = new THREE.SphereGeometry(0.3, 16, 16);

	    geometry.translate(0, 1.7, 0);
	    applesGeometry.merge(geometry);

	    geometry.translate(-1, -1, -1);
	    applesGeometry.merge(geometry);

	    geometry.translate(0, 0, 2);
	    applesGeometry.merge(geometry);

	    geometry.translate(2, 0, 0);
	    applesGeometry.merge(geometry);

	    geometry.translate(0, 0, -2);
	    applesGeometry.merge(geometry);

	    var buffGeometry = new THREE.BufferGeometry().fromGeometry(applesGeometry);
	    var material = new THREE.MeshStandardMaterial({ color: 0xff1122, side: THREE.DoubleSide, roughness: 1, metalness: 0 });
	    var apples = new THREE.Mesh(buffGeometry, material);
	    apples.position.set(0, 0, 0);
	    return apples;
	};

	var BushFactory = function () {
	    var ico = new THREE.Mesh(
	        new THREE.IcosahedronBufferGeometry(2),
	        new THREE.MeshStandardMaterial({color: 0x085f23, metalness: 0, roughness: 0.2})
	    );
	    ico.position.set(0, -0.4, 0);
	    ico.castShadow = true;
	    ico.receiveShadow = true;
	    ico.add(AppleFactory$1());
	    ico.scale.set(0.7, 0.7, 0.7);
	    return ico;
	};

	var Factory$3 = function () {
	    return {
	        Model: BushFactory(),
	        initServer: function initServer(entity) {
	            var Config = config$1;
	            entity.addScript('fight', function () {
	                entity[Config.PROPS.Status] = Config.STATUS.Fighting;
	                setTimeout(function () { return entity[Config.PROPS.Status] = Config.STATUS.Static; }, 400);
	            });
	        },
	        initClient: function initClient(entity) {
	            var Config = config$1;
	            var Model = entity.body.getObjectByName('Model');
	            var Fighting = {
	                animating: false,
	                animate: function animate() {
	                    if (!Fighting.animating) {
	                        Fighting.animating = true;
	                        TinyAnimate.animate(0, -0.3, 100, Fighting.update, 'easeIn', function () {
	                            TinyAnimate.animate(-0.3, 0, 400, Fighting.update, 'easeOut', function () {
	                                Fighting.animating = false;
	                            });
	                        });
	                    }
	                },
	                update: function update(pos) {
	                    Model.position.z = pos;
	                }
	            };

	            entity.addScript('tick', function (dt) {
	                if (entity[Config.PROPS.Status] === Config.STATUS.Fighting) {
	                    Fighting.animate();
	                }
	            });
	        }
	    };
	};

	var bushEntityFactory = Factory$3;

	var NET_TYPES = {
	    Player: 0,
	    Tree: 1,
	    Stone: 2,
	    Iron: 3,
	    Silver: 4,
	    Gold: 5,
	    Bush: 6
	};

	var ENTITIES = {};
	ENTITIES[NET_TYPES.Player] = playerEntityFactory;
	ENTITIES[NET_TYPES.Tree] = treeEntityFactory;
	ENTITIES[NET_TYPES.Stone] = rockEntityFactory('stone');
	ENTITIES[NET_TYPES.Iron] = rockEntityFactory('iron');
	ENTITIES[NET_TYPES.Silver] = rockEntityFactory('silver');
	ENTITIES[NET_TYPES.Gold] = rockEntityFactory('gold');
	ENTITIES[NET_TYPES.Bush] = bushEntityFactory;

	var STATUS = {
	    Static: 0,
	    Fighting: 1
	};

	// NOTE: Set only the props that will be sent to the client
	var PROPS = {
	    NetType: 'a',
	    Position: 'b',
	    Quaternion: 'c',
	    Scale: 'd',
	    Lerp: 'e',
	    Status: 'f',
	    Resources: 'g',
	    Inventory: 'h'
	};

	var RESOURCES = {
	    Wood: 'a',
	    Stone: 'b',
	    Iron: 'c',
	    Silver: 'd',
	    Gold: 'e',
	    Food: 'f'
	};

	var INVENTORY = {
	    Knife: {id: 'a', wood: 25, stone: 25, damage: 2, range: 0},
	    Axe: {id: 'b', wood: 50, stone: 50, damage: 1, range: 0.5},
	    Spear: {id: 'c', wood: 100, stone: 100, damage: 3, range: 1}
	};

	var config$1 = {
	    PROPS: PROPS,
	    NET_TYPES: NET_TYPES,
	    ENTITIES: ENTITIES,
	    STATUS: STATUS,
	    RESOURCES: RESOURCES,
	    INVENTORY: INVENTORY
	};
	var config_1 = config$1.PROPS;
	var config_5 = config$1.RESOURCES;
	var config_6 = config$1.INVENTORY;

	var Factory$4 = function (Game) {
	    Game.player[config_1.Resources] = {};
	    Object.values(config_5).forEach(function (item) { return Game.player[config_1.Resources][item] = 0; });

	    Game.player[config_1.Inventory] = {};
	    Object.values(config_6).forEach(function (item) { return Game.player[config_1.Inventory][item.id] = 0; });

	    Game.player.addScript('buy', function (name) {
	        Game.player.socket.emit('buy', name);
	    });

	    Game.socket.on('updatePlayer', function (data) {
	        if (Game.player) {
	            Object.assign(Game.player, data);
	        }
	    });

	    // Camera
	    Game.player.addScript('topDownCamera', function (dt) {
	        Game.app.camera.position.copy(Game.player.body.position);
	        Game.app.camera.position.y += 15;
	        // Game.app.camera.position.y += 220;
	        Game.app.camera.position.z += 8;
	        Game.app.camera.lookAt(Game.player.body.position);
	    });

	    Game.player.addScript('tick', function (dt) {
	        Game.player.runScript('topDownCamera', dt);
	    });

	    Game.player.addScript('keyboard', KeyboardScriptFactory(Game));
	    Game.player.addScript('end', function () {
	        if (Game.keyboard.target === Game.canvas) {
	            Game.player.runScript('keyboard');
	        }
	    });
	};

	var PROPS$1 = config$1.PROPS;
	var NET_TYPES$1 = config$1.NET_TYPES;
	var ENTITIES$1 = config$1.ENTITIES;
	var STATUS$1 = config$1.STATUS;
	var RESOURCES$1 = config$1.RESOURCES;
	var INVENTORY$1 = config$1.INVENTORY;

	var Entities = {
	    isNode: typeof window === 'undefined',
	    PROPS: PROPS$1,
	    STATUS: STATUS$1,
	    NET_TYPES: NET_TYPES$1,
	    RESOURCES: RESOURCES$1,
	    INVENTORY: INVENTORY$1,
	    Factories: {},
	    init: function init() {
	        for (var nt in ENTITIES$1) {
	            Entities.Factories[nt] = ENTITIES$1[nt]();
	        }
	    },
	    create: function create(data) {
	        if ( data === void 0 ) data = {};

	        var entity = {
	            id: data.id || (0 | Math.random() * 6.04e7).toString(36),
	            body: new THREE.Object3D(),
	            parent: undefined,
	            remove: false
	        };
	        entity[PROPS$1.NetType] = data[PROPS$1.NetType] || 0;
	        entity[PROPS$1.Position] = data[PROPS$1.Position] || {x: 0, y: 1, z: 0};
	        entity[PROPS$1.Quaternion] = data[PROPS$1.Quaternion] || {x: 0, y: 0, z: 0, w: 0};
	        entity[PROPS$1.Scale] = data[PROPS$1.Scale] || 1;
	        entity[PROPS$1.Lerp] = data[PROPS$1.Lerp] || 1;
	        entity[PROPS$1.Status] = data[PROPS$1.Status] || 0;
	        entity.destroy = function destroy() {
	                if (entity && entity.body && entity.body.parent) {
	                    entity.body.parent.remove(entity.body);
	                }

	                if (Entities.isNode) {
	                    delete Game.worlds[entity.world].children[entity.id];
	                }

	                delete entity.parent.children[entity.id];
	                entity = undefined;
	            };
	        entity.update = function update(dt) {
	                // Update position on the client
	                if (!Entities.isNode) {
	                    if (entity[PROPS$1.Lerp] === 1) {
	                        entity.body.position.copy(entity[PROPS$1.Position]);
	                    } else if (entity[PROPS$1.Lerp] < 1) {
	                        entity.body.position.lerp(
	                            new THREE.Vector3(
	                                entity[PROPS$1.Position].x,
	                                entity[PROPS$1.Position].y,
	                                entity[PROPS$1.Position].z
	                            ),
	                            entity[PROPS$1.Lerp]
	                        );
	                    }

	                    entity.body.quaternion.copy(entity[PROPS$1.Quaternion]);
	                }

	                entity.runScript('start', dt);

	                entity.runEveryTimers(dt);

	                entity.runScript('tick', dt);

	                // Copy position that will be sent to the client
	                if (Entities.isNode) {
	                    entity[PROPS$1.Position] = entity.body.position;
	                    entity[PROPS$1.Quaternion] = entity.body.quaternion;
	                }

	                entity.runScript('end', dt);

	                if (Entities.isNode && entity.remove) {
	                    entity.destroy();
	                }
	            };
	        entity.every = function every(nameOrTime, handler) {
	                if (entity.timers[nameOrTime] === undefined) {
	                    entity.timers[nameOrTime] = {
	                        timer: Date.now(),
	                        handlers: []
	                    };
	                }

	                if (typeof handler === 'function') {
	                    entity.timers[nameOrTime].handlers.push(handler);
	                }
	                return;
	            };
	        entity.runEveryTimers = function runEveryTimers() {
	                for (var i in entity.timers) {
	                    if (
	                        entity.timers[i].handlers.length > 0 &&
	                        Date.now() - entity.timers[i].timer > +i
	                    ) {
	                        var dt = (Date.now() - entity.timers[i].timer) * .001;
	                        for (var k = 0, l = entity.timers[i].handlers.length; k < l; k++) {
	                            entity.timers[i].handlers[k](dt);
	                        }
	                        entity.timers[i].timer = Date.now();
	                    }
	                }
	            };
	        entity.timers = {
	                // '100': {timer: Date.now(), handlers: []},
	            };
	        entity.addScript = function addScript(name, handler) {
	                if (entity.scripts[name] === undefined) {
	                    entity.scripts[name] = [];
	                }

	                if (typeof handler === 'function') {
	                    entity.scripts[name].push(handler);
	                }
	            };
	        entity.runScript = function runScript(name) {
	                var ref;

	                var args = [], len = arguments.length - 1;
	                while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];
	                if (entity.scripts[name].length > 0) {
	                    for (var i = 0, l = entity.scripts[name].length; i < l; i++) {
	                        (ref = entity.scripts[name])[i].apply(ref, args);
	                    }
	                }
	            };
	        entity.scripts = {
	                'start': [],
	                'tick': [],
	                'end': []
	            };
	        entity.limit = function limit(distance) {
	                if ( distance === void 0 ) distance = 100;

	                if (entity.body.position.x < -distance) {
	                    entity.body.position.x = -distance;
	                }
	                if (entity.body.position.x > distance) {
	                    entity.body.position.x = distance;
	                }
	                if (entity.body.position.z < -distance) {
	                    entity.body.position.z = -distance;
	                }
	                if (entity.body.position.z > distance) {
	                    entity.body.position.z = distance;
	                }
	            };

	        // Clone the model and set its initial position
	        // At serverside we don't need the real model, just handle the Object3D props
	        if (!Entities.isNode && Entities.Factories[data[PROPS$1.NetType]].Model) {
	            var Model = Entities.Factories[data[PROPS$1.NetType]].Model.clone();
	            Model.name = 'Model';
	            entity.body.add(Model);
	        }

	        entity.body.position.set(
	            entity[PROPS$1.Position].x,
	            entity[PROPS$1.Position].y,
	            entity[PROPS$1.Position].z
	        );

	        entity.body.quaternion.set(
	            entity[PROPS$1.Quaternion].x,
	            entity[PROPS$1.Quaternion].y,
	            entity[PROPS$1.Quaternion].z,
	            entity[PROPS$1.Quaternion].w
	        );

	        // Init the entity

	        if (Entities.isNode && typeof Entities.Factories[entity[PROPS$1.NetType]].initServer === 'function') {
	            Entities.Factories[entity[PROPS$1.NetType]].initServer(entity);
	        }

	        if (!Entities.isNode && typeof Entities.Factories[entity[PROPS$1.NetType]].initClient === 'function') {
	            Entities.Factories[entity[PROPS$1.NetType]].initClient(entity);
	        }

	        // Set the world and the socket that belongs to this entity if any
	        if (Entities.isNode) {
	            entity.world = data.world;
	        }

	        // If there is a socket property add it to the entity
	        if (data.socket !== undefined) {
	            entity.socket = data.socket;
	        }

	        return entity;
	    }
	};

	var entities = Entities;

	/**
	 * This keyboard handler will be used both sides (server and client)
	 * to get the pressed keys by the user
	 */

	var modifiers = {
	    '': 16, shift: 16,
	    '': 18, alt: 18, option: 18,
	    '': 17, ctrl: 17, control: 17,
	    '': 91, command: 91
	};

	var special = {
	    backspace: 8, tab: 9, clear: 12,
	    enter: 13, 'return': 13,
	    esc: 27, escape: 27, space: 32,
	    left: 37, up: 38,
	    right: 39, down: 40,
	    del: 46, 'delete': 46,
	    home: 36, end: 35,
	    pageup: 33, pagedown: 34,
	    ',': 188, '.': 190, '/': 191,
	    '`': 192, '-': 189, '=': 187,
	    ';': 186, '\'': 222,
	    '[': 219, ']': 221, '\\': 220
	};

	var f = {
	    f1: 112,
	    f2: 113,
	    f3: 114,
	    f4: 115,
	    f5: 116,
	    f6: 117,
	    f7: 118,
	    f8: 119,
	    f9: 120,
	    f10: 121,
	    f11: 122,
	    f12: 123
	};

	var mouse = {
	    left: 1,
	    right: 3,
	    middle: 2
	};

	var KeyboardFactory = function (element, preventContext) {
	    if ( preventContext === void 0 ) preventContext = true;

	    var Keyboard = {
	        target: null,
	        pressedKeys: [],
	        mouse: {
	            x: 0,
	            y: 0,
	            b: [],
	            d: 0
	        },
	        clearMouseDelta: null,
	        code: function code(x) {
	            return special[x] ||
	                modifiers[x] ||
	                f[x] ||
	                x.toUpperCase().charCodeAt(0);
	        },
	        isKeyPressed: function isKeyPressed(x) {
	            return Keyboard.pressedKeys.indexOf(Keyboard.code(x)) !== -1;
	        },
	        pressKey: function pressKey(key) {
	            var code = Keyboard.code(key);
	            if (Keyboard.pressedKeys.indexOf(code) === -1) {
	                Keyboard.pressedKeys.push(code);
	            }
	        },
	        isButtonPressed: function isButtonPressed(x) {
	            return Keyboard.mouse.b.indexOf(mouse[x]) !== -1;
	        },
	        pressButton: function pressButton(x) {
	            if (Keyboard.mouse.b.indexOf(mouse[x]) === -1) {
	                Keyboard.mouse.b.push(mouse[x]);
	            }
	        },
	        keyListener: function keyListener(event) {
	            if (event.type === 'keydown') {
	                Keyboard.target = event.target;
	                if (Keyboard.pressedKeys.indexOf(event.keyCode) === -1) {
	                    Keyboard.pressedKeys.push(event.keyCode);
	                }
	                return;
	            }

	            if (event.type === 'keyup') {
	                var index = Keyboard.pressedKeys.indexOf(event.keyCode);
	                if (index !== -1) {
	                    Keyboard.pressedKeys.splice(index, 1);
	                }
	            }
	        },
	        mouseListener: function mouseListener(event) {
	            Keyboard.target = event.target;
	            Keyboard.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
	            Keyboard.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

	            // Fix cross browser button that triggered the event
	            event.which ? event.which :
	                event.button === 1 ? 1 :
	                    event.button === 2 ? 3 :
	                        event.button === 4 ? 2 : 1;

	            if (event.type.indexOf('mousedown') !== -1) {
	                if (Keyboard.mouse.b.indexOf(event.which) === -1) {
	                    Keyboard.mouse.b.push(event.which);
	                }
	                return;
	            }

	            if (event.type.indexOf('mouseup') !== -1) {
	                var index = Keyboard.mouse.b.indexOf(event.which);
	                if (index !== -1) {
	                    Keyboard.mouse.b.splice(index, 1);
	                }
	            }

	            if (event.type.indexOf('mousewheel') !== -1 || event.type.indexOf('DOMMouseScroll') !== -1) {
	                var delta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));
	                Keyboard.mouse.d = delta;
	                clearTimeout(Keyboard.clearMouseDelta);
	                Keyboard.clearMouseDelta = setTimeout(function () {
	                    Keyboard.mouse.d = 0;
	                }, 150);
	            }
	        },
	        addEvent: function addEvent(type, handler) {
	            if (element !== undefined) {
	                var el = typeof element === 'string'
	                    ? document.querySelectorAll(element)[0]
	                    : element;

	                if (el.addEventListener) {
	                    el.addEventListener(type, handler, false);
	                    if (type === 'mousewheel') {
	                        el.addEventListener('DOMMouseScroll', handler, false);
	                    }
	                } else {
	                    el.attachEvent(("on" + type), handler);
	                }

	            }
	        },
	        preventContext: function preventContext(event) {
	            event.preventDefault();
	        },
	        reset: function reset() {
	            Keyboard.pressedKeys = [];
	            Keyboard.mouse.b = [];
	            Keyboard.mouse.d = 0;
	        }
	    };

	    Keyboard.addEvent('keydown', Keyboard.keyListener);
	    Keyboard.addEvent('keyup', Keyboard.keyListener);
	    Keyboard.addEvent('mousemove', Keyboard.mouseListener);
	    Keyboard.addEvent('mousedown', Keyboard.mouseListener);
	    Keyboard.addEvent('mouseup', Keyboard.mouseListener);
	    Keyboard.addEvent('mousewheel', Keyboard.mouseListener);
	    Keyboard.addEvent('contextmenu', Keyboard.preventContext);

	    return Keyboard;
	};

	var keyboardFactory = KeyboardFactory;

	var Game$1 = {
	    config: config,
	    deltaTime: Date.now(),
	    is: {
	        ready: false,
	        connecting: false,
	        connected: false
	    },
	    ready: false,
	    quality: 0.7,
	    app: null,
	    children: {},
	    keyboard: null,
	    canvas: null,
	    initGame: function initGame() {return __async(function*(){
	        AppFactory(Game$1);
	        Game$1.setQuality();

	        entities.init();
	        Game$1.connection = ConnectionFactory(Game$1);
	        Game$1.connection.initSocket(Game$1.config.serverUrl);
	        Game$1.keyboard = keyboardFactory(document.body);

	        Game$1.update();
	        yield Game$1.getWorlds();
	        Game$1.is.ready = true;
	    }())},
	    update: function update() {
	        requestAnimationFrame(function () { return Game$1.update(); });

	        var dt = (Date.now() - Game$1.deltaTime) * .001;

	        for (var i in Game$1.children) {
	            Game$1.children[i].update(dt);
	        }

	        Game$1.deltaTime = Date.now();
	        Game$1.app.renderer.render(Game$1.app.scene, Game$1.app.camera);
	    },
	    setQuality: function setQuality(pixelRatio) {
	        if ( pixelRatio === void 0 ) pixelRatio = 0.7;

	        Game$1.quality = pixelRatio;
	        Game$1.app.renderer.setPixelRatio(window.devicePixelRatio * Game$1.quality);
	        Game$1.app.renderer.setSize(window.innerWidth, window.innerHeight);
	    },
	    addEntity: function addEntity(childEntity) {
	        Game$1.children[childEntity.id] = childEntity;
	        childEntity.parent = Game$1;
	        Game$1.app.scene.add(childEntity.body);
	    },
	    updateWorld: function updateWorld(worldEntities) {
	        for (var i in Game$1.children) {
	            if (worldEntities[i] === undefined) {
	                Game$1.children[i].destroy();
	            }
	        }

	        for (var i$1 in worldEntities) {
	            /**
	             * Entity must be undefined and must not be the player,
	             * we will handle the creation of the creation of the player entity
	             * when the connectServer promise resolve
	             */
	            if (Game$1.children[i$1] === undefined && worldEntities[i$1].id !== Game$1.socket.id) {
	                var entity = entities.create(worldEntities[i$1]);
	                Game$1.addEntity(entity);
	            } else {
	                if (Game$1.children[i$1] !== undefined) {
	                    Object.assign(Game$1.children[i$1], worldEntities[i$1]);
	                }
	            }
	        }
	    },
	    setPlayerScripts: Factory$4,
	    connectServer: function connectServer() {return __async(function*(){
	        if (Game$1.is.ready && !Game$1.is.connecting && !Game$1.is.connected) {
	            Game$1.is.connecting = true;
	            var player = yield Game$1.connection.connectServer(Game$1.selectedWorld);
	            var entity = entities.create(player);
	            Game$1.addEntity(entity);
	            Game$1.player = entity;
	            Game$1.setPlayerScripts(Game$1);
	            Game$1.is.connected = true;
	            Game$1.is.connecting = false;
	        }
	    }())},
	    selectedWorld: null,
	    worlds: {},
	    getWorlds: function getWorlds() {return __async(function*(){
	        var worlds = yield Game$1.connection.getWorlds();
	        var selected = false;
	        for (var world in worlds) {
	            worlds[world].selected = false;
	            worlds[world].disabled = false;
	            if (
	                !selected &&
	                worlds[world].playerCount < worlds[world].maxPlayers
	            ) {
	                worlds[world].selected = true;
	                Game$1.selectedWorld = world;
	                selected = true;
	            }
	            if (worlds[world].playerCount >= worlds[world].maxPlayers) {
	                worlds[world].disabled = true;
	            }
	        }
	        Game$1.worlds = worlds;
	    }())},
	    selectWorld: function selectWorld(name) {
	        for (var world in Game$1.worlds) {
	            if (world === name) {
	                Game$1.worlds[world].selected = true;
	                Game$1.selectedWorld = world;
	            } else {
	                Game$1.worlds[world].selected = false;
	            }
	        }
	    },
	    fixedProps: function fixedProps(obj, precision) {
	        if ( obj === void 0 ) obj = {};
	        if ( precision === void 0 ) precision = 3;

	        var o = Array.isArray(obj) ? [] : {};

	        for (var i in obj) {
	            if (typeof obj[i] === 'object') {
	                o[i] = Game$1.fixedProps(obj[i]);
	                continue;
	            }

	            if (typeof obj[i] === 'number') {
	                o[i] = +(obj[i]).toFixed(precision);
	                continue;
	            }

	            o[i] = obj[i];
	        }

	        return o;
	    }
	};

	var Page = {
	    autologin: true,
	    getOptions: function getOptions() {
	        var options = [];
	        for (var name in Game$1.worlds) {
	            var world = Game$1.worlds[name];
	            options.push(
	                v( 'option', { value: name, disabled: world.disabled, selected: world.selected }, "World ", name, " - (", world.playerCount, "/", world.maxPlayers, ")")
	            );
	        }
	        return options;
	    },
	    selectWorld: function selectWorld(e) {
	        Game$1.selectWorld(e.target.value);
	    },
	    play: function play() {
	        Game$1.connectServer();
	        // v.routes.go('/game');
	    },
	    onupdate: function onupdate() {
	        if (Game$1.player) {
	            v.routes.go('/game');
	            return;
	        }

	        if (Page.autologin && Game$1.is.ready && !Game$1.is.connecting && !Game$1.is.connected) {
	            Page.play();
	        }
	    },
	    view: function view() {
	        return v( 'article', { onupdate: Page.onupdate },
	            v( Panel, { position: "center middle" }
	                /* {v.trust(logo)} */,
	                v( 'div', { 'data-flex': "" },
	                    v( Panel, { position: "inline", color: "white" },
	                        v( 'input', { placeholder: "Player name" }),
	                        v( 'select', { onchange: Page.selectWorld },
	                            Page.getOptions()
	                        ),
	                        v( 'button', {
	                            onclick: Page.play, 'data-background': "success", disabled: !Game$1.is.ready || Game$1.is.connecting, class: "w100" },
	                            Game$1.is.connecting ? 'Connecting...' : Game$1.is.ready ? 'Play' : 'Loading...'
	                        )
	                    ),
	                    v( Panel, { position: "inline", color: "white" }, "How to play"),
	                    v( Panel, { position: "inline", color: "white" }, "Best scores")
	                )
	            )
	        );
	    }
	};

	var Page$1 = {
	    onupdate: function onupdate() {
	        if (!Game$1.player) {
	            v.routes.go('/');
	        }
	    },
	    colors: {
	        white: '#ffffff',
	        black: '#555555',
	        success: '#00e676',
	        warning: '#ff3d00',
	        info: '#2979ff',
	        danger: '#ff1744'
	    },
	    buy: function buy(event) {
	        Game$1.player.runScript('buy', event.target.dataset.item);
	    },
	    getBuyButton: function getBuyButton(name) {
	        var item = config_6[name];
	        return v( 'button', { onclick: Page$1.buy, 'data-item': name }, "Wooden ", name, " (wood: ", item.wood, " | stone: ", item.stone, ")");
	    },
	    getStore: function getStore() {
	        return Object.keys(config_6).map(function (name) {
	            var resources = Game$1.player[config_1.Resources];
	            var item = config_6[name];
	            var level = Game$1.player[config_1.Inventory][item.id];
	            if (
	                level === 0
	                && item.wood <= resources[config_5.Wood]
	                && item.stone <= resources[config_5.Stone]
	            ) {
	                return Page$1.getBuyButton(name);
	            }
	        });
	    },
	    getItems: function getItems() {
	        return Object.keys(config_6).map(function (name) {
	            var item = config_6[name];
	            return v( Panel, { position: "inline", color: "black" }, name, " ", Game$1.player[config_1.Inventory][item.id]);
	        });
	    },
	    getResources: function getResources() {
	        return Object.keys(config_5).map(function (item) {
	            return v( 'div', null, item, ": ", Game$1.player[config_1.Resources][config_5[item]] );
	        });
	    },
	    view: function view() {
	        if (Game$1.player) {
	            return v( 'article', { oninit: Page$1.onupdate, onupdate: Page$1.onupdate },
	                v( Panel, { position: "left top" },
	                    v( Panel, { title: "Resources", position: "inline", color: "black" }, Page$1.getResources()),
	                    v( Panel, { position: "inline" }, Page$1.getStore())
	                ),

	                v( Panel, { position: "bottom center" }, Page$1.getItems()),


	                v( Panel, { position: "center" }, "Welcome, this is the game ui. ", v( 'br', null ),
	                    Game$1.player[config_1.Position].x, "/", Game$1.player[config_1.Position].z
	                ),
	                v( Panel, { position: "top right" },
	                    Object.keys(Page$1.colors).map(function (color) { return v( 'div', { 'data-background': color }, color, " ", Page$1.colors[color]); })
	                )
	            );
	        }
	        return v( 'article', { oninit: Page$1.onupdate, onupdate: Page$1.onupdate });
	    }
	};

	var Pages = {
	    Main: Main,
	    Home: Page,
	    Game: Page$1
	};

	var router = v.Router();
	router
	    .get('/', function () { return Pages.Home; })
	    .get('/game', function () { return Pages.Game; })
	;

	v.routes('#ui', router);

	if (v.is.browser) {
	    Game$1.initGame();
	    setInterval(function () { return v.update(); }, 100);
	}

	// Export what is needed for the backend
	var index = {Pages: Pages};

	return index;

})));
//# sourceMappingURL=index.min.js.map

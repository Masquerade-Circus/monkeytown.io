(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.App = factory());
}(this, (function () { 'use strict';

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	!function(){var e,n,o,t,i=[];function d(e,n,o,t,i){if("string"==typeof e){for(t in o={name:e,props:{},children:[],dom:null,isVnode:!0,nt:1,isSVG:"svg"===e},n){ o.props[t]=n[t]; }return d.utils.flat(arguments,2,o.children,!0),o}return "function"==typeof e?Object.assign({view:e,isComponent:!0},n):"object"==typeof e&&("function"==typeof e.view&&Object.assign(e,{isComponent:!0}),e.isComponent)?(i=e.view.apply(e,d.utils.flat(arguments,1,[])),Array.isArray(i)?i:[i]):void 0}function r(e,n){return 3===e.nodeType?{name:"#text",isVnode:!0,nodeValue:e.nodeValue,children:[],dom:e,nt:3}:1===e.nodeType?("svg"===(n={name:e.nodeName.toLowerCase(),props:{},children:[],dom:e,isVnode:!0,nodeValue:null,nt:1}).name&&(n.isSVG=!0),n.dom.events={},Array.prototype.map.call(e.attributes,function(e){n.props[e.nodeName]=e.nodeValue;}),Array.prototype.forEach.call(e.childNodes,function(e){var o=r(e);void 0!==o&&n.children.push(o);}),n):void 0}function s(e,n,o,t,i){if(1===e.nt&&(void 0!==e.props[n]&&e.props[n](e,o),"onremove"===n)){for(t=0,i=e.children.length;t<i;t++){ s(e.children[t],"onremove"); }e.children=[];}}function l(e){void 0!==e.currentTarget.events["on"+event.type]&&e.currentTarget.events["on"+event.type](e),d.update();}d.utils={flat:function(e,n,o,t,i){for(i=e.length,void 0===t&&(t=!1);n<i;n++){ Array.isArray(e[n])?o=d.utils.flat(e[n],0,o):(!1===t||void 0!==e[n]&&null!==e[n])&&o.push(e[n]); }return o}},(d.is={node:"undefined"==typeof window,mounted:!1,updating:!1}).browser=!d.is.node,d.trust=function(e){var n=document.createElement("div");return n.innerHTML=e.trim(),Array.prototype.map.call(n.childNodes,function (e){ return r(e); })},d.update=function(i){return "object"==typeof(i=d.utils.flat(arguments,0,[]))[0]&&i[0].isComponent&&(e=i.shift()),new Promise(function(r){if(!d.is.updating){if(d.is.updating=!0,i.unshift(e),o=d.apply(d,i),function e(n,o,t,i,r,u,p,a,m,c){if(0!==o.length){ for(r=o.length>t.length?o.length:t.length,a=0;a<r;a++){ if(p=t[a],void 0!==(u=o[a])){ if(void 0!==u.nt&&3!==u.nt){if(m=!d.is.mounted,i=i||u.isSVG,void 0===p){ s(u,"oninit"),u.dom=i?document.createElementNS("http://www.w3.org/2000/svg",u.name):document.createElement(u.name),u.dom.events={},n.appendChild(u.dom),p={children:[]},m=!0; }else if(u.name!==p.name){ s(u,"oninit"),u.dom=i?document.createElementNS("http://www.w3.org/2000/svg",u.name):document.createElement(u.name),u.dom.events={},s(p,"onremove"),n.replaceChild(u.dom,p.dom),m=!0; }else { for(c in u.dom=p.dom,p.props){ if(void 0===u.props[c]){if("function"==typeof p.props[c]){u.dom.removeEventListener(c.slice(2),l);continue}if(d.is.node||i||void 0===u.dom[c]){u.dom.removeAttribute(c);continue}u.dom[c]=null;} } }for(c in e(u.dom,u.children,p.children,i),u.props){ if((m||u.props[c]!==p.props[c])&&void 0!==u.props[c]){if("function"==typeof u.props[c]){switch(c){case"oninit":case"oncreate":case"onupdate":case"onremove":break;default:void 0===u.dom.events[c]&&(u.dom.events[c]=u.props[c],u.dom.addEventListener(c.slice(2),l));}continue}if(d.is.node||i||void 0===u.dom[c]){u.dom.setAttribute(c,u.props[c]);continue}u.dom[c]=u.props[c];} }d.is.mounted||m||(s(u,"oninit"),s(u,"oncreate")),s(u,m?"oncreate":"onupdate",p);}else { void 0===u.nt&&(o[a]=u={name:"#text",isVnode:!0,nodeValue:u,children:[],nt:3}),void 0===p?(u.dom=document.createTextNode(u.nodeValue),n.appendChild(u.dom)):1===p.nt?(u.dom=document.createTextNode(u.nodeValue),s(p,"onremove"),n.replaceChild(u.dom,p.dom)):(u.dom=p.dom,u.nodeValue!=p.nodeValue&&(u.dom.nodeValue=u.nodeValue)); } }else { void 0!==p&&(3===p.nt&&s(p,"onremove"),n.removeChild(p.dom)); } } }else { n.textContent=""; }}(t,o,n),n=o,d.is.updating=!1,d.is.mounted=!0,d.is.node){ return r(t.innerHTML); }r();}})},d.mount=function(e,o){return t=d.is.node?document.createElement("div"):"string"==typeof e?document.querySelectorAll(e)[0]:e,n=r(t).children,d.update.apply(this,d.utils.flat(arguments,1,[]))},d.use=function(e,n){return -1===i.indexOf(e)&&(e(d,n),i.push(e)),d},(d.is.node?commonjsGlobal:window).v=d;}();

	/**
	 * Handles the mix of single and array of middlewares
	 * @method parseMiddlewares
	 * @param  {Function|Array}         middlewares     // Middleware or array of middlewares
	 * @param  {Array}                  [array=[]]      // The array to store the final list of middlewares
	 * @return {Array}                                  // The final list of middlewares
	 */
	var parseMiddlewares = function (middlewares, array) {
	    if ( array === void 0 ) array = [];

	    if (typeof middlewares === 'function') {
	        array.push(middlewares);
	        return array;
	    }

	    var i = 0, l = middlewares.length;
	    for (; i < l; i++) {
	        if (Array.isArray(middlewares[i])) {
	            parseMiddlewares(middlewares[i], array);
	            continue;
	        }

	        array.push(middlewares[i]);
	    }
	    return array;
	};

	/**
	 * @description Adds a path to a router
	 * @method addPath
	 * @param  {Router} router              The router in which to add the path
	 * @param  {String} method              The method that will handle this path
	 * @param  {Array} args                The mixed params (String|Function|Array)
	 * @returns {Router}                    The router
	 */
	var addPath = function (router, method, args) {
	    var path, middlewares;

	    // Get the first argument
	    if (typeof args[0] === 'string') {
	        path = args.shift();
	    }

	    // If the seccond argument is a function and has paths
	    // and regexpList properties then
	    // Treat it as a subrouter
	    if (
	        typeof args[0] === 'function' &&
	        args[0].paths &&
	        args[0].regexpList
	    ) {
	        var subrouter = args.shift(),
	            i = 0,
	            l = subrouter.paths.length;

	        // For each path of the subrouter
	        for (; i < l; i++) {
	            var submiddlewares = subrouter.paths[i].middlewares;
	            var submethod = subrouter.paths[i].method;
	            var subpath = subrouter.paths[i].path;

	            // If there is a path add it as prefix to the subpath
	            if (path) {
	                subpath = path + (subpath || '*');
	            }

	            // If there is a subpath set it as the first element
	            // on the submiddlewares array
	            if (subpath) {
	                submiddlewares.unshift(subpath);
	            }

	            // Add the path to the router
	            router = addPath(router, submethod, submiddlewares);
	        }
	    }

	    // Parse middlwares to handle mixed arrays of middlwares and sequenced middlwares
	    middlewares = parseMiddlewares(args);

	    // Add the path only if there are middlewares passed
	    if (middlewares.length > 0) {
	        // If the path wasn't set before, set the regexp and params list
	        if (path && router.regexpList[path] === undefined) {
	            // Remove the last slash
	            path = path.replace(/\/(\?.*)?$/gi, '$1');

	            // Find the express like params
	            var params = path.match(/:(\w+)?/gi) || [];

	            // Set the names of the params found
	            for (var i$1 in params) {
	                params[i$1] = params[i$1].slice(1);
	            }

	            var regexpPath = path
	                // Catch params
	                .replace(/:(\w+)/gi, '([^\\s\\/|\\?]+)')
	                // To set to any url with the path as prefix
	                .replace(/\*/g, '.*')
	                // Remove the last slash
	                .replace(/\/(\?.*)?$/gi, '$1');

	            // Set the object to the path
	            router.regexpList[path] = {
	                regexp: new RegExp('^' + regexpPath + '/?(\\?.*)?$', 'gi'),
	                params: params
	            };
	        }

	        // Add the path to the paths list
	        router.paths.push({
	            method: method,
	            path: path,
	            middlewares: middlewares
	        });
	    }

	    return router;
	};

	var RouterFactory = function () {
	    /**
	     * new Rotuer
	     * @param  {String}    url     The path to call
	     * @return {Any}           The final response
	     */
	    var Router = async function (url) {
	        if ( url === void 0 ) url = '/';

	        var method = 'get',
	            params = {},
	            middlewares = [],
	            response,
	            i = 0,
	            l = Router.paths.length;

	        Router.url = url;

	        for (; i < l; i++) {
	            var path = Router.paths[i];
	            if (method !== path.method && path.method !== 'use') {
	                continue;
	            }

	            if ((path.method === 'use' || method === path.method) && path.path === undefined) {
	                parseMiddlewares(path.middlewares, middlewares);
	                continue;
	            }

	            var reg = Router.regexpList[path.path];
	            var matches = reg.regexp.exec(url);
	            reg.regexp.lastIndex = -1;
	            if (Array.isArray(matches)) {
	                matches.shift();
	                var regparams = reg.params;
	                var l$1 = regparams.length;
	                for (; l$1--;) {
	                    if (params[regparams[l$1]] === undefined) {
	                        params[regparams[l$1]] = matches[l$1];
	                    }
	                }
	                parseMiddlewares(path.middlewares, middlewares);
	            }
	        }

	        Router.params = params;

	        if (middlewares.length > 0) {
	            var i$1 = 0, l$2 = middlewares.length;
	            // call sequentially every middleware
	            for (; i$1 < l$2; i$1++) {
	                response = await middlewares[i$1](params);
	                // If there is a response
	                // break the for block
	                if (response) {
	                    return response;
	                }
	            }
	        }

	        if (Router.throwNotFound) {
	            // If no response was sent to the client throw an error
	            throw new Error(("The url " + url + " requested wasn't found"));
	        }
	    };

	    Router.url = '/';
	    Router.params = {};
	    Router.throwNotFound = true;

	    /**
	     * Where to store the paths and its middlewares
	     * @type {Object}
	     */
	    Router.paths = [];

	    /**
	     * Where to store the regexp and params list for the paths
	     * @type {[type]}
	     */
	    Router.regexpList = {};

	    // For each accepted method, add the method to the router
	    Router.get = function () {
	        return addPath(Router, 'get', v.utils.flat(arguments, 0, []));
	    };
	    Router.use = function () {
	        return addPath(Router, 'use', v.utils.flat(arguments, 0, []));
	    };

	    /**
	     * Return the new router
	     * @type {Router}
	     */
	    return Router;
	};


	var plugin = function (v) {
	    var mainRouter;
	    var RoutesContainer;
	    function runRoute(parentComponent, url, args) {
	        return mainRouter(url)
	            .then(function (response) {
	                if (typeof response !== 'object') {
	                    throw new Error('v.router.component.required');
	                }

	                if (!response.isComponent && typeof response.view === 'function') {
	                    Object.assign(response, {isComponent: true});
	                }

	                if (!response.isComponent) {
	                    throw new Error('v.router.component.required');
	                }

	                if (parentComponent) {
	                    args.unshift(v(response, args));
	                    response = parentComponent;
	                }

	                args.unshift(response);

	                if (v.is.node || !v.is.mounted) {
	                    args.unshift(RoutesContainer);
	                    return v.mount.apply(v, args);
	                }

	                return v.update.apply(v, args);
	            });
	    }
	    v.routes = function (elementContainer, router) {
	        if (elementContainer && router) {
	            mainRouter = router;
	            RoutesContainer = elementContainer;
	            // Activate the use of the router
	            if (v.is.browser) {
	                function onPopStateGoToRoute() {
	                    v.routes.go(document.location.pathname);
	                }
	                window.addEventListener('popstate', onPopStateGoToRoute, false);
	                onPopStateGoToRoute();
	            }
	        }
	    };

	    v.routes.get = function () {
	        var routes = [];
	        mainRouter.paths.forEach(function (path) {
	            if (path.method === 'get') {
	                routes.push(path.path === '' ? '/' : path.path);
	            }
	        });
	        return routes;
	    };

	    v.routes.current = '/';
	    v.routes.params = {};

	    v.routes.go = function () {
	        var args = v.utils.flat(arguments, 0, []);
	        var parentComponent;
	        var url;

	        if (typeof args[0] === 'object') {
	            if (!args[0].isComponent && typeof args[0].view === 'function') {
	                args[0] = Object.assign(args[0], {isComponent: true});
	            }

	            if (args[0].isComponent) {
	                parentComponent = args.shift();
	            }
	        }

	        if (typeof args[0] === 'string') {
	            url = args.shift();
	        }

	        if (!url) {
	            throw new Error('v.router.url.required');
	        }

	        if (v.is.browser) {
	            window.history.pushState({}, '', url);
	        }

	        return runRoute(parentComponent, url, args);
	    };

	    v.Router = RouterFactory;
	};

	var plugin$1 = function (v) {
	    var Request = function (baseUrl, options) {
	        if ( baseUrl === void 0 ) baseUrl = '';
	        if ( options === void 0 ) options = {};

	        var url = baseUrl.replace(/\/$/gi, '').trim(),
	            opts = Object.assign({
	                methods: ['get', 'post', 'put', 'patch', 'delete']
	            }, options),
	            parseUrl;

	        function serialize(obj, prefix) {
	            var e = encodeURIComponent;
	            return Object.keys(obj)
	                .map(function (p) {
	                    var k = prefix ? prefix + '[' + p + ']' : p;

	                    return typeof obj[p] === 'object'
	                        ? serialize(obj[p], k)
	                        : e(k) + '=' + e(obj[p]);
	                })
	                .join('&');
	        }

	        function request(method, url, data, options) {
	            if ( options === void 0 ) options = {};

	            var opts = Object.assign({
	                    method: method.toLowerCase(),
	                    headers: {
	                        'Accept': 'application/json',
	                        'Content-Type': 'application/json'
	                    }
	                }, request.options, options),
	                type = opts.headers.Accept;

	            if (data !== undefined) {
	                if (opts.method === 'get' && typeof data === 'object') {
	                    url += data = serialize(data);
	                }

	                if (opts.method !== 'get') {
	                    opts.body = JSON.stringify(data);
	                }
	            }

	            return fetch(parseUrl(url), opts)
	                .then(function (response) {
	                    if (response.status < 200 || response.status > 300) {
	                        var err = new Error(response.statusText);
	                        err.response = response;
	                        throw err;
	                    }

	                    if (/text/gi.test(type)) {
	                        return response.text();
	                    }

	                    if (/json/gi.test(type)) {
	                        return response.json();
	                    }

	                    return response;
	                });
	        }
	        parseUrl = function (url) {
	            var u = /^https?/gi.test(url)
	                ? url
	                : (request.baseUrl + '/' + url).trim().replace(/^\/\//gi, '/').trim();

	            if (
	                v.is.node &&
	                typeof request.nodeUrl === 'string'
	            ) {
	                request.nodeUrl = request.nodeUrl.replace(/\/$/gi, '').trim();

	                if (/^https?/gi.test(u) && typeof request.apiUrl === 'string') {
	                    request.apiUrl = request.apiUrl.replace(/\/$/gi, '').trim();
	                    u = u.replace(request.apiUrl, request.nodeUrl);
	                }

	                if (!/^https?/gi.test(u)) {
	                    u = request.nodeUrl + u;
	                }
	            }

	            return u;
	        };

	        request.new = function (baseUrl, options) {
	            return Request(baseUrl, options);
	        };

	        // Change this to  request.urls.api etc...
	        request.apiUrl = undefined;
	        request.nodeUrl = undefined;
	        request.options = opts;
	        request.baseUrl = url;

	        opts.methods.forEach(function (method) { return request[method] = function (url, data, options) { return request(method, url, data, options); }; }
	        );

	        return request;
	    };

	    v.request = Request();
	};

	var PROPS = {
	    netType: 'n',
	    position: 'p',
	    quaternion: 'q',
	    scale: 's',
	    body: 'b',
	    lerp: 'l',
	    remove: 'r'
	};

	var props = PROPS;

	var ModelFactory = function () {
	    var sphere = new THREE.Mesh(
	        new THREE.SphereGeometry(1, 32, 32),
	        new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide })
	    );
	    sphere.receiveShadow = true;
	    sphere.castShadow = true;
	    return sphere;
	};

	var ServerUpdate = function (entity) { return function (dt) {
	    entity.body.position.x += 1 * dt;
	}; };

	var ClientUpdate = function (entity) { return function (dt) {
	    // entity.body.position.x += 1 * dt;
	}; };

	var Factory = function () {
	    return {
	        Model: ModelFactory(),
	        init: function init(entity) {
	            if (Entities.isNode) {
	                entity.updateMethod = ServerUpdate(entity);
	            } else {
	                entity.updateMethod = ClientUpdate(entity);
	            }
	        }
	    };
	};

	var entityPlayer = Factory;

	var TYPES = {
	    Player: 1
	};

	var Entities$1 = {
	    isNode: typeof window === 'undefined',
	    PROPS: props,
	    TYPES: TYPES,
	    Factories: {},
	    init: function init() {
	        Entities$1.Factories[TYPES.Player] = entityPlayer();
	    },
	    create: function create(data) {
	        if ( data === void 0 ) data = {};

	        var entity = {
	            id: data.id || (0 | Math.random() * 6.04e7).toString(36),
	            body: new THREE.Object3D(),
	            parent: undefined
	        };
	        entity[props.netType] = data[props.netType] || 0;
	        entity[props.position] = data[props.position] || {x: 0, y: 1, z: 0};
	        entity[props.quaternion] = data[props.quaternion] || {x: 0, y: 0, z: 0, w: 0};
	        entity[props.scale] = data[props.scale] || 1;
	        entity[props.lerp] = data[props.lerp] || 1;
	        entity[props.remove] = false;
	        entity.destroy = function destroy() {
	                if (entity && entity.body && entity.body.parent) {
	                    entity.body.parent.remove(entity.body);
	                }

	                if (Entities$1.isNode) {
	                    delete Game.worlds[entity.world].children[entity.id];
	                }

	                delete Game.children[entity.id];
	                entity = undefined;
	            };
	        entity.update = function update(dt) {
	                if (!Entities$1.isNode) {
	                    // Update position on the client
	                    if (entity[props.lerp] === 1) {
	                        entity.body.position.copy(entity[props.position]);
	                    } else if (entity[props.lerp] < 1) {
	                        entity.body.position.lerp(
	                            new THREE.Vector3(
	                                entity[props.position].x,
	                                entity[props.position].y,
	                                entity[props.position].z
	                            ),
	                            entity[props.lerp]
	                        );
	                    }

	                    entity.body.quaternion.copy(entity[props.quaternion]);
	                }

	                entity.updateMethod(dt);

	                if (Entities$1.isNode) {
	                    // Copy position that will be sent to the client
	                    entity[props.position] = entity.body.position;
	                    entity[props.quaternion] = entity.body.quaternion;
	                }
	            };

	        // Clone the model and set its initial position
	        if (Entities$1.Factories[data[props.netType]].Model) {
	            entity.body.add(Entities$1.Factories[data[props.netType]].Model.clone());
	        }

	        entity.body.position.set(
	            entity[props.position].x,
	            entity[props.position].y,
	            entity[props.position].z
	        );

	        entity.body.quaternion.set(
	            entity[props.quaternion].x,
	            entity[props.quaternion].y,
	            entity[props.quaternion].z,
	            entity[props.quaternion].w
	        );

	        // Init the entity
	        if (typeof Entities$1.Factories[entity[props.netType]].init === 'function') {
	            Entities$1.Factories[entity[props.netType]].init(entity);
	        }

	        // Set the world and the socket that belongs to this entity if any
	        if (Entities$1.isNode) {
	            entity.world = data.world;
	            entity.socket = data.socket;
	        }

	        return entity;
	    }
	};

	var entities = Entities$1;

	v
	    .use(plugin)
	    .use(plugin$1)
	;

	(v.is.browser ? window : global).Entities = entities;

	var displayName = "MonkeyTown.io";
	var description = "Build your monkey home and survive";
	var version = "0.0.1";

	var Main = {
	    title: displayName,
	    version: version,
	    description: description,
	    id: (0 | Math.random() * 6.04e7).toString(36), // change this to version when publish
	    view: function view() {
	        var children = [], len = arguments.length;
	        while ( len-- ) children[ len ] = arguments[ len ];

	        var view = v( 'html', { lang: "en" },
	            v( 'head', null,
	                v( 'title', null, Main.title ),
	                v( 'meta', { charset: "utf-8" }),
	                v( 'meta', { name: "description", content: Main.description }),
	                v( 'meta', { 'http-equiv': "x-UA-Compatible", content: "IE=edge" }),
	                v( 'meta', { name: "viewport", content: "width=device-width, initial-scale=1, maximum-scale=5, minimal-ui" }),
	                v( 'link', { href: "/css/main.css", rel: "stylesheet" }),
	                v( 'link', { rel: "shortcut icon", href: "/imgs/favicon.ico" })
	            ),
	            v( 'body', null,
	                v( 'div', { id: "ui" },
	                    children,
	                    v( 'script', { src: ("/js/socket.io.js?v=" + (Main.id)) }),
	                    v( 'script', { src: ("/js/three.min.js?v=" + (Main.id)) }),
	                    v( 'script', { src: ("/js/index.min.js?v=" + (Main.id)) })
	                )
	            )
	        );

	        return view;
	    }
	};

	var logo = "<svg xmlns=\"http://www.w3.org/2000/svg\" id=\"svg8\" viewBox=\"0 0 226.284 259.667\"><defs id=\"defs2\"><style id=\"style10\"/></defs><g id=\"layer1\" transform=\"translate(77.306 43.657)\"><path id=\"path4589-8-3-3\" stroke-width=\".973\" d=\"M-64.674-41.219s-65.49 163.606 101.758 257.229c65.706-22.68 111.511-80.827 111.894-136.648-5.013 16.407-10.762 56.552-69.466 94.502 74.755-57.952 81.097-154.15 53.071-217.521 9.58 82.156-20.177 161.842-87.54 195.51-14.639-10.04-13.465-58.947-9.618-64.92l8.602 18.93-4.055-19.962s1.904 4.065 7.137 10.828c-7.034-22.458-2.503-45.013-2.503-45.013s-15.16 18.105-38.687 28.6c7.643-.205 12.362-1.204 14.356-1.806-3.589 2.655-16.814 8.894-16.814 8.894l19.12-4.064s-14.61 28.48-9.01 67.365C-31.625 109.497-73.901 45.869-64.673-41.22z\"/><path id=\"rect3996\" stroke-width=\".278\" d=\"M189.08-37.278h473.023v310.401H189.08z\" opacity=\".01\"/></g></svg>";

	var Home = v(function () { return v( 'article', null,
	        v( 'div', { id: "home-middle" },
	            v( 'div', null, v.trust(logo) ),
	            v( 'br', null ),
	            v( 'div', null, "Hello world" )
	        )
	    ); }
	);

	var Pages = {
	    Main: Main,
	    Home: Home
	};

	var config = {
	    dev: true,
	    localUrl: 'http://localhost:3000',
	    serverUrl: 'http://localhost:3000'
	};

	var AppFactory = function () {
	    var app = {};

	    app.scene = new THREE.Scene();
	    app.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
	    app.camera.position.set(0, 100, 100);
	    app.camera.lookAt(new THREE.Vector3(0, 0, 0));
	    app.scene.add(app.camera);

	    app.mixer = new THREE.AnimationMixer(app.scene);

	    app.listener = new THREE.AudioListener();
	    app.camera.add(app.listener);

	    app.renderer = new THREE.WebGLRenderer({ antialias: true });
	    app.renderer.setPixelRatio(window.devicePixelRatio);
	    app.renderer.setSize(window.innerWidth, window.innerHeight);
	    app.renderer.shadowMap.enabled = true;
	    app.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

	    window.addEventListener('resize', function () {
	        app.camera.aspect = window.innerWidth / window.innerHeight;
	        app.camera.updateProjectionMatrix();
	        app.renderer.setSize(window.innerWidth, window.innerHeight);
	    });
	    document.body.appendChild(app.renderer.domElement);
	    app.renderer.domElement.setAttribute('tabindex', '0');
	    app.renderer.domElement.setAttribute('id', 'game-canvas');

	    app.light = new THREE.DirectionalLight(0xffffff, 0.9);
	    app.light.position.set(2, 4, 3);
	    app.light.castShadow = true;
	    app.scene.add(app.light);

	    app.ambientlight = new THREE.AmbientLight(0x999999);
	    app.scene.add(app.ambientlight);


	    app.ground = new THREE.Mesh(
	        new THREE.PlaneGeometry(1000, 1000),
	        new THREE.MeshStandardMaterial({color: 0x9cff57, side: THREE.DoubleSide})
	    );
	    app.ground.rotation.x = -(Math.PI / 2);
	    app.ground.castShadow = false;
	    app.ground.receiveShadow = true;
	    app.ground.position.set(0, 0, 0);
	    app.scene.add(app.ground);

	    return app;
	};

	var Connection = {
	    initSocket: function initSocket(url) {
	        if (window.socket !== undefined) {
	            window.socket.disconnect();
	            window.socket = undefined;
	        }

	        window.socket = io(url);
	        socket.on('world', function (data) { return Game.updateWorld(data); });
	    },
	    connectServer: function connectServer(world) {
	        if ( world === void 0 ) world = 'Alpha';

	        return new Promise(function (resolve) {
	            socket.emit('connectServer', world, function () {
	                Game.playerId = socket.id;

	                resolve();
	            });
	        });
	    }
	};

	var test = function (Game) {

	    Game.connection.connectServer();
	};

	var Game$1 = {
	    config: config,
	    deltaTime: Date.now(),
	    ready: false,
	    quality: 0.8,
	    app: null,
	    children: {},
	    connection: Connection,
	    initGame: function initGame() {
	        Game$1.app = AppFactory();
	        Game$1.setQuality();

	        Entities.init();
	        Connection.initSocket(Game$1.config.serverUrl);
	        test(Game$1);

	        Game$1.update();
	        Game$1.ready = true;
	    },
	    update: function update() {
	        var dt = (Date.now() - Game$1.deltaTime) * .001;

	        for (var i in Game$1.children) {
	            Game$1.children[i].update(dt);
	        }

	        Game$1.deltaTime = Date.now();
	        Game$1.app.renderer.render(Game$1.app.scene, Game$1.app.camera);
	        requestAnimationFrame(function () { return Game$1.update(); });
	    },
	    setQuality: function setQuality(pixelRatio) {
	        if ( pixelRatio === void 0 ) pixelRatio = 0.8;

	        Game$1.quality = pixelRatio;
	        Game$1.app.renderer.setPixelRatio(window.devicePixelRatio * Game$1.quality);
	        Game$1.app.renderer.setSize(window.innerWidth, window.innerHeight);
	    },
	    addEntity: function addEntity(childEntity) {
	        Game$1.children[childEntity.id] = childEntity;
	        childEntity.parent = Game$1;
	        Game$1.app.scene.add(childEntity.body);
	    },
	    updateWorld: function updateWorld(world) {
	        for (var i in Game$1.children) {
	            if (world.children[i] === undefined) {
	                Game$1.children[i].destroy();
	            }
	        }

	        for (var i$1 in world.children) {
	            if (Game$1.children[i$1] === undefined) {
	                var entity = Entities.create(world.children[i$1]);
	                Game$1.addEntity(entity);
	                if (i$1 === Game$1.playerId) {
	                    Game$1.setPlayer(Game$1.children[i$1]);
	                }
	            } else {
	                Object.assign(Game$1.children[i$1], world.children[i$1]);
	            }
	        }
	    },
	    setPlayer: function setPlayer(entity) {
	        Game$1.player = entity;
	        Game$1.app.camera.position.set(0, 10, 10);
	        Game$1.app.camera.lookAt(0, 0, 0);
	    }
	};

	var router = v.Router();
	router
	    .get('/', function () { return Pages.Home; })
	;

	v.routes('#ui', router);

	if (v.is.browser) {
	    window.Game = Game$1;
	    Game$1.initGame();
	}

	// Export what is needed for the backend
	var index = {Pages: Pages};

	return index;

})));
//# sourceMappingURL=index.min.js.map

{"version":3,"file":"index.min.js","sources":["../../node_modules/valyrian.js/plugins/router.js","../../node_modules/valyrian.js/plugins/request.js","../../app/client/connection-factory.js","../../app/client/test.js","../../app/client/player-scripts/index.js","../../app/entities/player-entity-factory.js","../../app/client/index.js"],"sourcesContent":["/**\n * Handles the mix of single and array of middlewares\n * @method parseMiddlewares\n * @param  {Function|Array}         middlewares     // Middleware or array of middlewares\n * @param  {Array}                  [array=[]]      // The array to store the final list of middlewares\n * @return {Array}                                  // The final list of middlewares\n */\nlet parseMiddlewares = (middlewares, array = []) => {\n    if (typeof middlewares === 'function') {\n        array.push(middlewares);\n        return array;\n    }\n\n    let i = 0, l = middlewares.length;\n    for (; i < l; i++) {\n        if (Array.isArray(middlewares[i])) {\n            parseMiddlewares(middlewares[i], array);\n            continue;\n        }\n\n        array.push(middlewares[i]);\n    }\n    return array;\n};\n\n/**\n * @description Adds a path to a router\n * @method addPath\n * @param  {Router} router              The router in which to add the path\n * @param  {String} method              The method that will handle this path\n * @param  {Array} args                The mixed params (String|Function|Array)\n * @returns {Router}                    The router\n */\nlet addPath = (router, method, args) => {\n    let path, middlewares;\n\n    // Get the first argument\n    if (typeof args[0] === 'string') {\n        path = args.shift();\n    }\n\n    // If the seccond argument is a function and has paths\n    // and regexpList properties then\n    // Treat it as a subrouter\n    if (\n        typeof args[0] === 'function' &&\n        args[0].paths &&\n        args[0].regexpList\n    ) {\n        let subrouter = args.shift(),\n            i = 0,\n            l = subrouter.paths.length;\n\n        // For each path of the subrouter\n        for (; i < l; i++) {\n            let submiddlewares = subrouter.paths[i].middlewares;\n            let submethod = subrouter.paths[i].method;\n            let subpath = subrouter.paths[i].path;\n\n            // If there is a path add it as prefix to the subpath\n            if (path) {\n                subpath = path + (subpath || '*');\n            }\n\n            // If there is a subpath set it as the first element\n            // on the submiddlewares array\n            if (subpath) {\n                submiddlewares.unshift(subpath);\n            }\n\n            // Add the path to the router\n            router = addPath(router, submethod, submiddlewares);\n        }\n    }\n\n    // Parse middlwares to handle mixed arrays of middlwares and sequenced middlwares\n    middlewares = parseMiddlewares(args);\n\n    // Add the path only if there are middlewares passed\n    if (middlewares.length > 0) {\n        // If the path wasn't set before, set the regexp and params list\n        if (path && router.regexpList[path] === undefined) {\n            // Remove the last slash\n            path = path.replace(/\\/(\\?.*)?$/gi, '$1');\n\n            // Find the express like params\n            let params = path.match(/:(\\w+)?/gi) || [];\n\n            // Set the names of the params found\n            for (let i in params) {\n                params[i] = params[i].slice(1);\n            }\n\n            let regexpPath = path\n                // Catch params\n                .replace(/:(\\w+)/gi, '([^\\\\s\\\\/|\\\\?]+)')\n                // To set to any url with the path as prefix\n                .replace(/\\*/g, '.*')\n                // Remove the last slash\n                .replace(/\\/(\\?.*)?$/gi, '$1');\n\n            // Set the object to the path\n            router.regexpList[path] = {\n                regexp: new RegExp('^' + regexpPath + '/?(\\\\?.*)?$', 'gi'),\n                params: params\n            };\n        }\n\n        // Add the path to the paths list\n        router.paths.push({\n            method: method,\n            path: path,\n            middlewares: middlewares\n        });\n    }\n\n    return router;\n};\n\nlet RouterFactory = () => {\n    /**\n     * new Rotuer\n     * @param  {String}    url     The path to call\n     * @return {Any}           The final response\n     */\n    let Router = async function (url = '/') {\n        let method = 'get',\n            params = {},\n            middlewares = [],\n            response,\n            i = 0,\n            l = Router.paths.length;\n\n        Router.url = url;\n\n        for (; i < l; i++) {\n            let path = Router.paths[i];\n            if (method !== path.method && path.method !== 'use') {\n                continue;\n            }\n\n            if ((path.method === 'use' || method === path.method) && path.path === undefined) {\n                parseMiddlewares(path.middlewares, middlewares);\n                continue;\n            }\n\n            let reg = Router.regexpList[path.path];\n            let matches = reg.regexp.exec(url);\n            reg.regexp.lastIndex = -1;\n            if (Array.isArray(matches)) {\n                matches.shift();\n                let regparams = reg.params;\n                let l = regparams.length;\n                for (; l--;) {\n                    if (params[regparams[l]] === undefined) {\n                        params[regparams[l]] = matches[l];\n                    }\n                }\n                parseMiddlewares(path.middlewares, middlewares);\n            }\n        }\n\n        Router.params = params;\n\n        if (middlewares.length > 0) {\n            let i = 0, l = middlewares.length;\n            // call sequentially every middleware\n            for (; i < l; i++) {\n                response = await middlewares[i](params);\n                // If there is a response\n                // break the for block\n                if (response) {\n                    return response;\n                }\n            }\n        }\n\n        if (Router.throwNotFound) {\n            // If no response was sent to the client throw an error\n            throw new Error(`The url ${url} requested wasn't found`);\n        }\n    };\n\n    Router.url = '/';\n    Router.params = {};\n    Router.throwNotFound = true;\n\n    /**\n     * Where to store the paths and its middlewares\n     * @type {Object}\n     */\n    Router.paths = [];\n\n    /**\n     * Where to store the regexp and params list for the paths\n     * @type {[type]}\n     */\n    Router.regexpList = {};\n\n    // For each accepted method, add the method to the router\n    Router.get = function () {\n        return addPath(Router, 'get', v.utils.flat(arguments, 0, []));\n    };\n    Router.use = function () {\n        return addPath(Router, 'use', v.utils.flat(arguments, 0, []));\n    };\n\n    /**\n     * Return the new router\n     * @type {Router}\n     */\n    return Router;\n};\n\n\nlet plugin = function (v) {\n    let mainRouter;\n    let RoutesContainer;\n    function runRoute(parentComponent, url, args) {\n        return mainRouter(url)\n            .then(response => {\n                if (typeof response !== 'object') {\n                    throw new Error('v.router.component.required');\n                }\n\n                if (!response.isComponent && typeof response.view === 'function') {\n                    Object.assign(response, {isComponent: true});\n                }\n\n                if (!response.isComponent) {\n                    throw new Error('v.router.component.required');\n                }\n\n                if (parentComponent) {\n                    args.unshift(v(response, args));\n                    response = parentComponent;\n                }\n\n                args.unshift(response);\n\n                if (v.is.node || !v.is.mounted) {\n                    args.unshift(RoutesContainer);\n                    return v.mount.apply(v, args);\n                }\n\n                return v.update.apply(v, args);\n            });\n    };\n\n    v.routes = function (elementContainer, router) {\n        if (elementContainer && router) {\n            mainRouter = router;\n            RoutesContainer = elementContainer;\n            // Activate the use of the router\n            if (v.is.browser) {\n                function onPopStateGoToRoute() {\n                    v.routes.go(document.location.pathname);\n                }\n                window.addEventListener('popstate', onPopStateGoToRoute, false);\n                onPopStateGoToRoute();\n            }\n        }\n    };\n\n    v.routes.get = function () {\n        let routes = [];\n        mainRouter.paths.forEach(path => {\n            if (path.method === 'get') {\n                routes.push(path.path === '' ? '/' : path.path);\n            }\n        });\n        return routes;\n    };\n\n    v.routes.current = '/';\n    v.routes.params = {};\n\n    v.routes.go = function () {\n        let args = v.utils.flat(arguments, 0, []);\n        let parentComponent;\n        let url;\n\n        if (typeof args[0] === 'object') {\n            if (!args[0].isComponent && typeof args[0].view === 'function') {\n                args[0] = Object.assign(args[0], {isComponent: true});\n            }\n\n            if (args[0].isComponent) {\n                parentComponent = args.shift();\n            }\n        }\n\n        if (typeof args[0] === 'string') {\n            url = args.shift();\n        }\n\n        if (!url) {\n            throw new Error('v.router.url.required');\n        }\n\n        if (v.is.browser) {\n            window.history.pushState({}, '', url);\n        }\n\n        return runRoute(parentComponent, url, args);\n    };\n\n    v.Router = RouterFactory;\n};\n\n// module.exports = plugin;\nexport default plugin;\n","let plugin = function (v) {\n    let Request = function (baseUrl = '', options = {}) {\n        let url = baseUrl.replace(/\\/$/gi, '').trim(),\n            opts = Object.assign({\n                methods: ['get', 'post', 'put', 'patch', 'delete']\n            }, options),\n            parseUrl;\n\n        function serialize(obj, prefix) {\n            let e = encodeURIComponent;\n            return Object.keys(obj)\n                .map((p) => {\n                    let k = prefix ? prefix + '[' + p + ']' : p;\n\n                    return typeof obj[p] === 'object'\n                        ? serialize(obj[p], k)\n                        : e(k) + '=' + e(obj[p]);\n                })\n                .join('&');\n        }\n\n        function request(method, url, data, options = {}) {\n            let opts = Object.assign({\n                    method: method.toLowerCase(),\n                    headers: {\n                        'Accept': 'application/json',\n                        'Content-Type': 'application/json'\n                    }\n                }, request.options, options),\n                type = opts.headers.Accept;\n\n            if (data !== undefined) {\n                if (opts.method === 'get' && typeof data === 'object') {\n                    url += data = serialize(data);\n                }\n\n                if (opts.method !== 'get') {\n                    opts.body = JSON.stringify(data);\n                }\n            }\n\n            return fetch(parseUrl(url), opts)\n                .then(response => {\n                    if (response.status < 200 || response.status > 300) {\n                        let err = new Error(response.statusText);\n                        err.response = response;\n                        throw err;\n                    }\n\n                    if (/text/gi.test(type)) {\n                        return response.text();\n                    }\n\n                    if (/json/gi.test(type)) {\n                        return response.json();\n                    }\n\n                    return response;\n                });\n        };\n\n        parseUrl = function (url) {\n            let u = /^https?/gi.test(url)\n                ? url\n                : (request.baseUrl + '/' + url).trim().replace(/^\\/\\//gi, '/').trim();\n\n            if (\n                v.is.node &&\n                typeof request.nodeUrl === 'string'\n            ) {\n                request.nodeUrl = request.nodeUrl.replace(/\\/$/gi, '').trim();\n\n                if (/^https?/gi.test(u) && typeof request.apiUrl === 'string') {\n                    request.apiUrl = request.apiUrl.replace(/\\/$/gi, '').trim();\n                    u = u.replace(request.apiUrl, request.nodeUrl);\n                }\n\n                if (!/^https?/gi.test(u)) {\n                    u = request.nodeUrl + u;\n                }\n            }\n\n            return u;\n        };\n\n        request.new = function (baseUrl, options) {\n            return Request(baseUrl, options);\n        };\n\n        // Change this to  request.urls.api etc...\n        request.apiUrl = undefined;\n        request.nodeUrl = undefined;\n        request.options = opts;\n        request.baseUrl = url;\n\n        opts.methods.forEach(method =>\n            request[method] = (url, data, options) => request(method, url, data, options)\n        );\n\n        return request;\n    };\n\n    v.request = Request();\n};\n\n// module.exports = plugin;\nexport default plugin;\n","const ConnectionFactory = (Game) => {\n    let Connection = {\n        initSocket(url) {\n            if (Game.socket !== undefined) {\n                Game.socket.disconnect();\n                Game.socket = undefined;\n            }\n\n            Game.socket = io(url);\n            Game.socket.on('world', data => Game.updateWorld(data));\n        },\n        connectServer(world = 'Alpha') {\n            return new Promise((resolve) => {\n                Game.socket.emit('connectServer', world, () => {\n                    Game.playerId = Game.socket.id;\n                    resolve();\n                });\n            });\n        },\n        getWorlds: () => new Promise((resolve) => Game.socket.emit('getWorlds', resolve))\n    };\n    return Connection;\n};\n\n\nexport default ConnectionFactory;\n","let test = function (Game) {\n\n    Game.connectServer();\n};\n\nexport default test;\n","let Factory = (Game) => {\n    // We will set the player scripts in here\n    Game.app.camera.position.set(0, 10, 10);\n    Game.app.camera.lookAt(0, 0, 0);\n};\n\nexport default Factory;\n","\nlet Factory = () => {\n    let sphere = new THREE.Mesh(\n        new THREE.SphereGeometry(1, 32, 32),\n        new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide })\n    );\n    sphere.receiveShadow = true;\n    sphere.castShadow = true;\n\n    return {\n        Model: sphere,\n        initServer(entity) {\n            entity.every(800, (dt) => {\n                entity.body.position.x += 20 * dt;\n            });\n            entity.addScript('movement', (dt, direction) => {\n                let howMuch = 0.5 * dt;\n                if (direction === 'left') {\n                    entity.body.position.x -= howMuch;\n                }\n                if (direction === 'right') {\n                    entity.body.position.x += howMuch;\n                }\n            });\n            entity.addScript('start', (dt) => {\n                entity.runScript('movement', dt, 'left');\n            });\n        },\n        initClient(entity) {\n\n        }\n    };\n};\n\nmodule.exports = Factory;\n","import config from './config';\nimport AppFactory from './app-factory';\nimport ConnectionFactory from './connection-factory';\nimport test from './test';\nimport PlayerScriptFactory from './player-scripts';\nimport Entities from '../entities';\n\nlet Connection = null;\n\nlet Game = {\n    config,\n    deltaTime: Date.now(),\n    ready: false,\n    quality: 0.8,\n    app: null,\n    children: {},\n    async initGame() {\n        Game.app = AppFactory();\n        Game.setQuality();\n\n        Entities.init();\n        Game.connection = ConnectionFactory(Game);\n        Game.connection.initSocket(Game.config.serverUrl);\n        test(Game);\n\n        Game.update();\n        await Game.getWorlds();\n        Game.ready = true;\n    },\n    update() {\n        let dt = (Date.now() - Game.deltaTime) * .001;\n\n        for (let i in Game.children) {\n            Game.children[i].update(dt);\n        }\n\n        Game.deltaTime = Date.now();\n        Game.app.renderer.render(Game.app.scene, Game.app.camera);\n        requestAnimationFrame(() => Game.update());\n    },\n    setQuality(pixelRatio = 0.8) {\n        Game.quality = pixelRatio;\n        Game.app.renderer.setPixelRatio(window.devicePixelRatio * Game.quality);\n        Game.app.renderer.setSize(window.innerWidth, window.innerHeight);\n    },\n    addEntity(childEntity) {\n        Game.children[childEntity.id] = childEntity;\n        childEntity.parent = Game;\n        Game.app.scene.add(childEntity.body);\n    },\n    updateWorld(world) {\n        for (let i in Game.children) {\n            if (world.children[i] === undefined) {\n                Game.children[i].destroy();\n            }\n        }\n\n        for (let i in world.children) {\n            if (Game.children[i] === undefined) {\n                let entity = Entities.create(world.children[i]);\n                Game.addEntity(entity);\n                if (i === Game.playerId) {\n                    Game.player = entity;\n                    Game.player.socket = Game.socket;\n                    Game.setPlayerScripts(Game);\n                }\n            } else {\n                Object.assign(Game.children[i], world.children[i]);\n            }\n        }\n    },\n    setPlayerScripts: PlayerScriptFactory,\n    connectServer: () => Game.connection.connectServer(),\n    worlds: {},\n    async getWorlds() {\n        let worlds = await Game.connection.getWorlds();\n        for (let world in worlds) {\n            worlds[world].selected = false;\n        }\n        Game.worlds = worlds;\n    }\n};\n\nexport default Game;\n"],"names":["let","const"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kBA6HuB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4BA2CI;;;;;;;;;;;;;SAavB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CCrLJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CCAAC;;;;;;;;;;;;;;;;;;;;;;;;;;CCAAD;;;;;CCAAA;;;;;;CCCAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KCeU;;;;;;;;;;SAUF;;SAEJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KA8CM;sBACW;;;;;SAKjB;;;;;;;;;;;;;;;;;;;;;;;"}
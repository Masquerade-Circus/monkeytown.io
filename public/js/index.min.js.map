{"version":3,"file":"index.min.js","sources":["../../node_modules/valyrian.js/plugins/request.js","../../node_modules/valyrian.js/plugins/router.js","../../app/client/connection-factory.js","../../app/client/player-scripts/keyboard-script-factory.js","../../app/shared/keyboard-factory.js","../../app/client/models/bush-factory.js","../../app/client/models/monkey-factory.js","../../app/client/models/rock-factory.js","../../app/client/models/tree-factory.js","../../app/client/models/knife-factory.js","../../app/client/index.js"],"sourcesContent":["let plugin = function (v) {\n    let Request = function (baseUrl = '', options = {}) {\n        let url = baseUrl.replace(/\\/$/gi, '').trim(),\n            opts = Object.assign({\n                methods: ['get', 'post', 'put', 'patch', 'delete']\n            }, options),\n            parseUrl;\n\n        function serialize(obj, prefix) {\n            let e = encodeURIComponent;\n            return Object.keys(obj)\n                .map((p) => {\n                    let k = prefix ? prefix + '[' + p + ']' : p;\n\n                    return typeof obj[p] === 'object'\n                        ? serialize(obj[p], k)\n                        : e(k) + '=' + e(obj[p]);\n                })\n                .join('&');\n        }\n\n        function request(method, url, data, options = {}) {\n            let opts = Object.assign({\n                    method: method.toLowerCase(),\n                    headers: {\n                        'Accept': 'application/json',\n                        'Content-Type': 'application/json'\n                    }\n                }, request.options, options),\n                type = opts.headers.Accept;\n\n            if (data !== undefined) {\n                if (opts.method === 'get' && typeof data === 'object') {\n                    url += data = serialize(data);\n                }\n\n                if (opts.method !== 'get') {\n                    opts.body = JSON.stringify(data);\n                }\n            }\n\n            return fetch(parseUrl(url), opts)\n                .then(response => {\n                    if (!response.ok) {\n                        let err = new Error(response.statusText);\n                        err.response = response;\n                        throw err;\n                    }\n\n                    if (/text/gi.test(type)) {\n                        return response.text();\n                    }\n\n                    if (/json/gi.test(type)) {\n                        return response.json();\n                    }\n\n                    return response;\n                });\n        };\n\n        parseUrl = function (url) {\n            let u = /^https?/gi.test(url)\n                ? url\n                : (request.urls.base + '/' + url).trim().replace(/^\\/\\//gi, '/').trim();\n\n            if (\n                v.is.node &&\n                typeof request.urls.node === 'string'\n            ) {\n                request.urls.node = request.urls.node.replace(/\\/$/gi, '').trim();\n\n                if (/^https?/gi.test(u) && typeof request.urls.api === 'string') {\n                    request.urls.api = request.urls.api.replace(/\\/$/gi, '').trim();\n                    u = u.replace(request.urls.api, request.urls.node);\n                }\n\n                if (!/^https?/gi.test(u)) {\n                    u = request.urls.node + u;\n                }\n            }\n\n            return u;\n        };\n\n        request.new = function (baseUrl, options) {\n            return Request(baseUrl, options);\n        };\n\n        request.urls = {};\n        request.urls.api = undefined;\n        request.urls.node = undefined;\n        request.urls.base = url;\n        request.options = opts;\n\n        opts.methods.forEach(method =>\n            request[method] = (url, data, options) => request(method, url, data, options)\n        );\n\n        return request;\n    };\n\n    v.request = Request();\n};\n\n// module.exports = plugin;\nexport default plugin;\n","/**\n * Handles the mix of single and array of middlewares\n * @method parseMiddlewares\n * @param  {Function|Array}         middlewares     // Middleware or array of middlewares\n * @param  {Array}                  [array=[]]      // The array to store the final list of middlewares\n * @return {Array}                                  // The final list of middlewares\n */\nlet parseMiddlewares = (middlewares, array = []) => {\n    if (typeof middlewares === 'function') {\n        array.push(middlewares);\n        return array;\n    }\n\n    let i = 0, l = middlewares.length;\n    for (; i < l; i++) {\n        if (Array.isArray(middlewares[i])) {\n            parseMiddlewares(middlewares[i], array);\n            continue;\n        }\n\n        array.push(middlewares[i]);\n    }\n    return array;\n};\n\n/**\n * @description Adds a path to a router\n * @method addPath\n * @param  {Router} router              The router in which to add the path\n * @param  {String} method              The method that will handle this path\n * @param  {Array} args                The mixed params (String|Function|Array)\n * @returns {Router}                    The router\n */\nlet addPath = (router, method, args) => {\n    let path, middlewares;\n\n    // Get the first argument\n    if (typeof args[0] === 'string') {\n        path = args.shift();\n    }\n\n    // If the seccond argument is a function and has paths\n    // and regexpList properties then\n    // Treat it as a subrouter\n    if (\n        typeof args[0] === 'function' &&\n        args[0].paths &&\n        args[0].regexpList\n    ) {\n        let subrouter = args.shift(),\n            i = 0,\n            l = subrouter.paths.length;\n\n        // For each path of the subrouter\n        for (; i < l; i++) {\n            let submiddlewares = subrouter.paths[i].middlewares;\n            let submethod = subrouter.paths[i].method;\n            let subpath = subrouter.paths[i].path;\n\n            // If there is a path add it as prefix to the subpath\n            if (path) {\n                subpath = path + (subpath || '*');\n            }\n\n            // If there is a subpath set it as the first element\n            // on the submiddlewares array\n            if (subpath) {\n                submiddlewares.unshift(subpath);\n            }\n\n            // Add the path to the router\n            router = addPath(router, submethod, submiddlewares);\n        }\n    }\n\n    // Parse middlwares to handle mixed arrays of middlwares and sequenced middlwares\n    middlewares = parseMiddlewares(args);\n\n    // Add the path only if there are middlewares passed\n    if (middlewares.length > 0) {\n        // If the path wasn't set before, set the regexp and params list\n        if (path && router.regexpList[path] === undefined) {\n            // Remove the last slash\n            path = path.replace(/\\/(\\?.*)?$/gi, '$1');\n\n            // Find the express like params\n            let params = path.match(/:(\\w+)?/gi) || [];\n\n            // Set the names of the params found\n            for (let i in params) {\n                params[i] = params[i].slice(1);\n            }\n\n            let regexpPath = path\n                // Catch params\n                .replace(/:(\\w+)/gi, '([^\\\\s\\\\/|\\\\?]+)')\n                // To set to any url with the path as prefix\n                .replace(/\\*/g, '.*')\n                // Remove the last slash\n                .replace(/\\/(\\?.*)?$/gi, '$1');\n\n            // Set the object to the path\n            router.regexpList[path] = {\n                regexp: new RegExp('^' + regexpPath + '/?(\\\\?.*)?$', 'gi'),\n                params: params\n            };\n        }\n\n        // Add the path to the paths list\n        router.paths.push({\n            method: method,\n            path: path,\n            middlewares: middlewares\n        });\n    }\n\n    return router;\n};\n\nlet RouterFactory = () => {\n    /**\n     * new Rotuer\n     * @param  {String}    url     The path to call\n     * @return {Any}           The final response\n     */\n    let Router = async function (url = '/') {\n        let method = 'get',\n            params = {},\n            middlewares = [],\n            response,\n            i = 0,\n            l = Router.paths.length;\n\n        Router.url = url;\n\n        for (; i < l; i++) {\n            let path = Router.paths[i];\n            if (method !== path.method && path.method !== 'use') {\n                continue;\n            }\n\n            if ((path.method === 'use' || method === path.method) && path.path === undefined) {\n                parseMiddlewares(path.middlewares, middlewares);\n                continue;\n            }\n\n            let reg = Router.regexpList[path.path];\n            let matches = reg.regexp.exec(url);\n            reg.regexp.lastIndex = -1;\n            if (Array.isArray(matches)) {\n                matches.shift();\n                let regparams = reg.params;\n                let l = regparams.length;\n                for (; l--;) {\n                    if (params[regparams[l]] === undefined) {\n                        params[regparams[l]] = matches[l];\n                    }\n                }\n                parseMiddlewares(path.middlewares, middlewares);\n            }\n        }\n\n        Router.params = params;\n\n        if (middlewares.length > 0) {\n            let i = 0, l = middlewares.length;\n            // call sequentially every middleware\n            for (; i < l; i++) {\n                response = await middlewares[i](params);\n                // If there is a response\n                // break the for block\n                if (response) {\n                    return response;\n                }\n            }\n        }\n\n        if (Router.throwNotFound) {\n            // If no response was sent to the client throw an error\n            throw new Error(`The url ${url} requested wasn't found`);\n        }\n    };\n\n    Router.url = '/';\n    Router.params = {};\n    Router.throwNotFound = true;\n\n    /**\n     * Where to store the paths and its middlewares\n     * @type {Object}\n     */\n    Router.paths = [];\n\n    /**\n     * Where to store the regexp and params list for the paths\n     * @type {[type]}\n     */\n    Router.regexpList = {};\n\n    // For each accepted method, add the method to the router\n    Router.get = function () {\n        return addPath(Router, 'get', v.utils.flat(arguments, 0, []));\n    };\n    Router.use = function () {\n        return addPath(Router, 'use', v.utils.flat(arguments, 0, []));\n    };\n\n    /**\n     * Return the new router\n     * @type {Router}\n     */\n    return Router;\n};\n\n\nlet plugin = function (v) {\n    let mainRouter;\n    let RoutesContainer;\n    function runRoute(parentComponent, url, args) {\n        return mainRouter(url)\n            .then(response => {\n                if (typeof response !== 'object') {\n                    throw new Error('v.router.component.required');\n                }\n\n                if (!response.isComponent && typeof response.view === 'function') {\n                    Object.assign(response, {isComponent: true});\n                }\n\n                if (!response.isComponent) {\n                    throw new Error('v.router.component.required');\n                }\n\n                if (parentComponent) {\n                    args.unshift(v(response, args));\n                    response = parentComponent;\n                }\n\n                args.unshift(response);\n\n                if (v.is.node || !v.is.mounted) {\n                    args.unshift(RoutesContainer);\n                    return v.mount.apply(v, args);\n                }\n\n                return v.update.apply(v, args);\n            });\n    };\n\n    v.routes = function (elementContainer, router) {\n        if (elementContainer && router) {\n            mainRouter = router;\n            RoutesContainer = elementContainer;\n            // Activate the use of the router\n            if (v.is.browser) {\n                function onPopStateGoToRoute() {\n                    v.routes.go(document.location.pathname);\n                }\n                window.addEventListener('popstate', onPopStateGoToRoute, false);\n                onPopStateGoToRoute();\n            }\n        }\n    };\n\n    v.routes.get = function () {\n        let routes = [];\n        mainRouter.paths.forEach(path => {\n            if (path.method === 'get') {\n                routes.push(path.path === '' ? '/' : path.path);\n            }\n        });\n        return routes;\n    };\n\n    v.routes.current = '/';\n    v.routes.params = {};\n\n    v.routes.go = function () {\n        let args = v.utils.flat(arguments, 0, []);\n        let parentComponent;\n        let url;\n\n        if (typeof args[0] === 'object') {\n            if (!args[0].isComponent && typeof args[0].view === 'function') {\n                args[0] = Object.assign(args[0], {isComponent: true});\n            }\n\n            if (args[0].isComponent) {\n                parentComponent = args.shift();\n            }\n        }\n\n        if (typeof args[0] === 'string') {\n            url = args.shift();\n        }\n\n        if (!url) {\n            throw new Error('v.router.url.required');\n        }\n\n        if (v.is.browser) {\n            window.history.pushState({}, '', url);\n        }\n\n        return runRoute(parentComponent, url, args);\n    };\n\n    v.Router = RouterFactory;\n};\n\n// module.exports = plugin;\nexport default plugin;\n","const ConnectionFactory = (Game) => {\n    let Connection = {\n        initSocket(url) {\n            if (Game.socket !== undefined) {\n                Game.socket.disconnect();\n                Game.socket = undefined;\n            }\n\n            Game.socket = io(url);\n\n            /**\n             * As we will destroy the player when socket disconnects\n             * with this we will reload the browser page if the user recconnects\n             */\n            Game.socket.on('reconnect', () => window.location.href = window.location.href);\n\n            // Custom game events\n            Game.socket.on('world', data => Game.updateWorld(data));\n        },\n        connectServer(world = 'Alpha') {\n            return new Promise((resolve) => {\n                Game.socket.emit('connectServer', world, (err, entity) => {\n                    if (err) {\n                        console.error(err);\n                        return;\n                    }\n                    entity.socket = Game.socket;\n                    resolve(entity);\n                });\n            });\n        },\n        getWorlds: () => new Promise((resolve) => Game.socket.emit('getWorlds', resolve))\n    };\n    return Connection;\n};\n\n\nexport default ConnectionFactory;\n","let KeyboardScriptFactory = (Game) => {\n    let raycaster = new THREE.Raycaster();\n    let mouse = new THREE.Vector2();\n    let intersects;\n\n    Game.keyboard.onChange((type, data) => {\n        if (Game.keyboard.target === Game.canvas) {\n            if (type === 'mousemove') {\n                if (mouse.x !== data.x || mouse.y !== data.y) {\n                    mouse.x = data.x;\n                    mouse.y = data.y;\n                    raycaster.setFromCamera(mouse, Game.app.camera);\n                    intersects = raycaster.intersectObjects([Game.app.ground]);\n                    if (intersects.length === 1) {\n                        let p = {\n                            x: intersects[0].point.x,\n                            y: intersects[0].point.y,\n                            z: intersects[0].point.z\n                        };\n                        Game.player.socket.emit('keyboard', type, Game.fixedProps(p));\n                    }\n                }\n                return;\n            }\n\n            Game.player.socket.emit('keyboard', type, data);\n        }\n    });\n};\n\nexport default KeyboardScriptFactory;\n","/**\n * This keyboard handler will be used both sides (server and client)\n * to get the pressed keys by the user\n */\n\nlet modifiers = {\n    '⇧': 16, shift: 16,\n    '⌥': 18, alt: 18, option: 18,\n    '⌃': 17, ctrl: 17, control: 17,\n    '⌘': 91, command: 91\n};\n\nlet special = {\n    backspace: 8, tab: 9, clear: 12,\n    enter: 13, 'return': 13,\n    esc: 27, escape: 27, space: 32,\n    left: 37, up: 38,\n    right: 39, down: 40,\n    del: 46, 'delete': 46,\n    home: 36, end: 35,\n    pageup: 33, pagedown: 34,\n    ',': 188, '.': 190, '/': 191,\n    '`': 192, '-': 189, '=': 187,\n    ';': 186, '\\'': 222,\n    '[': 219, ']': 221, '\\\\': 220\n};\n\nlet f = {\n    f1: 112,\n    f2: 113,\n    f3: 114,\n    f4: 115,\n    f5: 116,\n    f6: 117,\n    f7: 118,\n    f8: 119,\n    f9: 120,\n    f10: 121,\n    f11: 122,\n    f12: 123\n};\n\nlet mouse = {\n    left: 1,\n    right: 3,\n    middle: 2\n};\n\nlet KeyboardFactory = function (element, preventContext = true) {\n    let Keyboard = {\n        target: null,\n        pressedKeys: [],\n        mouse: {\n            p: {\n                x: 0,\n                y: 0\n            },\n            b: [],\n            d: 0\n        },\n        clearMouseDelta: null,\n        code(x) {\n            return special[x] ||\n                modifiers[x] ||\n                f[x] ||\n                x.toUpperCase().charCodeAt(0);\n        },\n        isKeyPressed(x) {\n            return Keyboard.pressedKeys.indexOf(Keyboard.code(x)) !== -1;\n        },\n        pressKey(key) {\n            let code = Keyboard.code(key);\n            if (Keyboard.pressedKeys.indexOf(code) === -1) {\n                Keyboard.pressedKeys.push(code);\n            }\n        },\n        isButtonPressed(x) {\n            return Keyboard.mouse.b.indexOf(mouse[x]) !== -1;\n        },\n        pressButton(x) {\n            if (Keyboard.mouse.b.indexOf(mouse[x]) === -1) {\n                Keyboard.mouse.b.push(mouse[x]);\n            }\n        },\n\n        changeHandlers: [],\n        onChange(handler) {\n            Keyboard.changeHandlers.push(handler);\n        },\n        run(...args) {\n            let i = 0;\n            let l = Keyboard.changeHandlers.length;\n            for (;i < l; i++) {\n                Keyboard.changeHandlers[i](...args);\n            }\n        },\n\n        keyListener(event) {\n            if (event.type === 'keydown') {\n                Keyboard.target = event.target;\n                if (Keyboard.pressedKeys.indexOf(event.keyCode) === -1) {\n                    Keyboard.pressedKeys.push(event.keyCode);\n                    Keyboard.run('keydown', Keyboard.pressedKeys);\n                }\n                return;\n            }\n\n            if (event.type === 'keyup') {\n                let index = Keyboard.pressedKeys.indexOf(event.keyCode);\n                if (index !== -1) {\n                    Keyboard.pressedKeys.splice(index, 1);\n                    Keyboard.run('keyup', Keyboard.pressedKeys);\n                }\n            }\n        },\n\n        mouseListener(event) {\n            Keyboard.target = event.target;\n            let prevMouse = {x: Keyboard.mouse.p.x, y: Keyboard.mouse.p.y};\n            Keyboard.mouse.p.x = (event.clientX / window.innerWidth) * 2 - 1;\n            Keyboard.mouse.p.y = -(event.clientY / window.innerHeight) * 2 + 1;\n            if (Keyboard.mouse.p.x !== prevMouse.x || Keyboard.mouse.p.y !== prevMouse.y) {\n                Keyboard.run('mousemove', Keyboard.mouse.p);\n            }\n\n            // Fix cross browser button that triggered the event\n            event.which ? event.which :\n                event.button === 1 ? 1 :\n                    event.button === 2 ? 3 :\n                        event.button === 4 ? 2 : 1;\n\n            if (event.type.indexOf('mousedown') !== -1) {\n                if (Keyboard.mouse.b.indexOf(event.which) === -1) {\n                    Keyboard.mouse.b.push(event.which);\n                    Keyboard.run('mousedown', Keyboard.mouse.b);\n                }\n                return;\n            }\n\n            if (event.type.indexOf('mouseup') !== -1) {\n                let index = Keyboard.mouse.b.indexOf(event.which);\n                if (index !== -1) {\n                    Keyboard.mouse.b.splice(index, 1);\n                    Keyboard.run('mouseup', Keyboard.mouse.b);\n                }\n            }\n\n            if (event.type.indexOf('mousewheel') !== -1 || event.type.indexOf('DOMMouseScroll') !== -1) {\n                let delta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));\n                Keyboard.mouse.d = delta;\n                Keyboard.run('mousewheel', Keyboard.mouse.d);\n                clearTimeout(Keyboard.clearMouseDelta);\n                Keyboard.clearMouseDelta = setTimeout(() => {\n                    Keyboard.mouse.d = 0;\n                    Keyboard.run('mousewheel', Keyboard.mouse.d);\n                }, 100);\n            }\n        },\n        addEvent(type, handler) {\n            if (element !== undefined) {\n                let el = typeof element === 'string'\n                    ? document.querySelectorAll(element)[0]\n                    : element;\n\n                if (el.addEventListener) {\n                    el.addEventListener(type, handler, false);\n                    if (type === 'mousewheel') {\n                        el.addEventListener('DOMMouseScroll', handler, false);\n                    }\n                } else {\n                    el.attachEvent(`on${type}`, handler);\n                }\n\n            }\n        },\n        preventContext(event) {\n            event.preventDefault();\n        },\n        reset() {\n            Keyboard.pressedKeys = [];\n            Keyboard.mouse.b = [];\n            Keyboard.mouse.d = 0;\n        }\n    };\n\n    Keyboard.addEvent('keydown', Keyboard.keyListener);\n    Keyboard.addEvent('keyup', Keyboard.keyListener);\n    Keyboard.addEvent('mousemove', Keyboard.mouseListener);\n    Keyboard.addEvent('mousedown', Keyboard.mouseListener);\n    Keyboard.addEvent('mouseup', Keyboard.mouseListener);\n    Keyboard.addEvent('mousewheel', Keyboard.mouseListener);\n    Keyboard.addEvent('contextmenu', Keyboard.preventContext);\n\n    return Keyboard;\n};\n\nmodule.exports = KeyboardFactory;\n","let AppleFactory = function () {\n    let applesGeometry = new THREE.Geometry();\n    let geometry = new THREE.SphereGeometry(0.3, 16, 16);\n\n    geometry.translate(0, 1.7, 0);\n    applesGeometry.merge(geometry);\n\n    geometry.translate(-1, -1, -1);\n    applesGeometry.merge(geometry);\n\n    geometry.translate(0, 0, 2);\n    applesGeometry.merge(geometry);\n\n    geometry.translate(2, 0, 0);\n    applesGeometry.merge(geometry);\n\n    geometry.translate(0, 0, -2);\n    applesGeometry.merge(geometry);\n\n    let buffGeometry = new THREE.BufferGeometry().fromGeometry(applesGeometry);\n    let material = new THREE.MeshStandardMaterial({ color: 0xff1122, side: THREE.DoubleSide, roughness: 1, metalness: 0 });\n    let apples = new THREE.Mesh(buffGeometry, material);\n    apples.position.set(0, 0, 0);\n    return apples;\n};\n\nlet BushFactory = function () {\n    let ico = new THREE.Mesh(\n        new THREE.IcosahedronBufferGeometry(2),\n        new THREE.MeshStandardMaterial({color: 0x085f23, metalness: 0, roughness: 0.2})\n    );\n    ico.position.set(0, -0.4, 0);\n    ico.castShadow = true;\n    ico.receiveShadow = true;\n    ico.add(AppleFactory());\n    ico.scale.set(0.7, 0.7, 0.7);\n    return ico;\n};\n\nexport default BushFactory;\n","let circle = function (rad, color, segments = 32) {\n    let geometry = new THREE.CircleBufferGeometry(rad, segments);\n    let material = new THREE.MeshStandardMaterial({ color, side: THREE.DoubleSide });\n    let circle = new THREE.Mesh(geometry, material);\n    circle.receiveShadow = true;\n    return circle;\n};\n\nlet MonkeyFactory = () => {\n    let hand = circle(0.8, 0x542207);\n    hand.position.set(-1.5, -1.5, -0.2);\n    let r = circle(0.74, 0xefcfa6);\n    r.position.set(0, 0, 0.1);\n    hand.add(r);\n    hand.castShadow = true;\n    hand.receiveShadow = true;\n\n    let hand2 = circle(0.8, 0x542207);\n    hand2.position.set(1.5, -1.5, -0.2);\n    let r2 = circle(0.74, 0xefcfa6);\n    r2.position.set(0, 0, 0.1);\n    hand2.add(r2);\n    hand2.castShadow = true;\n    hand2.receiveShadow = true;\n\n    let ear = circle(0.6, 0x542207);\n    ear.position.set(-2.1, 0, -0.2);\n    let ei = circle(0.4, 0xe0ac7d);\n    ei.position.set(0.1, -0.1, 0.1);\n    ear.add(ei);\n    ear.castShadow = true;\n    ear.receiveShadow = true;\n\n    let ear2 = circle(0.6, 0x542207);\n    ear2.position.set(2.1, 0, -0.2);\n    let ei2 = circle(0.4, 0xe0ac7d);\n    ei2.position.set(-0.1, -0.1, 0.1);\n    ear2.add(ei2);\n    ear2.castShadow = true;\n    ear2.receiveShadow = true;\n\n    let monkey = circle(2, 0x542207);\n\n    let mouth = circle(1, 0xefcfa6);\n    mouth.position.set(0, -1, 0.1);\n    let n = circle(0.1, 0x000000);\n    n.position.set(-0.15, -0.15, 0.1);\n    mouth.add(n);\n    let n2 = circle(0.1, 0x000000);\n    n2.position.set(0.15, -0.15, 0.1);\n    mouth.add(n2);\n\n    let eye1 = circle(1, 0xefcfa6);\n    eye1.position.set(-0.9, -0.1, 0.1);\n    let p = circle(0.3, 0x000000);\n    p.position.set(0, -0.2, 0.1);\n    eye1.add(p);\n    let pl = circle(0.1, 0xffffff);\n    pl.position.set(0, -0.1, 0.1);\n    p.add(pl);\n\n    let eye2 = circle(1, 0xefcfa6);\n    eye2.position.set(0.9, -0.1, 0.1);\n    let p2 = circle(0.3, 0x000000);\n    p2.position.set(0, -0.2, 0.1);\n    eye2.add(p2);\n    let pl2 = circle(0.1, 0xffffff);\n    pl2.position.set(0, -0.1, 0.1);\n    p2.add(pl2);\n\n    monkey.add(hand);\n    monkey.add(hand2);\n    monkey.add(ear2);\n    monkey.add(ear);\n    monkey.add(eye1);\n    monkey.add(eye2);\n    monkey.add(mouth);\n\n    monkey.rotation.x = -(Math.PI / 2);\n    monkey.scale.set(0.5, 0.5, 0.5);\n\n    monkey.castShadow = true;\n    monkey.receiveShadow = true;\n\n    let object = new THREE.Object3D();\n    object.add(monkey);\n    return object;\n};\n\nexport default MonkeyFactory;\n","let RockFactory = (Type) => () => {\n    let data;\n    switch (Type) {\n        case 'Gold':\n            data = {color: 0xFFD700};\n            break;\n        case 'Silver':\n            data = {color: 0xCBCDCD};\n            break;\n        case 'Iron':\n            data = {color: 0x828383};\n            break;\n        case 'Stone':\n            data = {color: 0x535454};\n            break;\n    }\n\n    let ico = new THREE.Mesh(\n        new THREE.IcosahedronBufferGeometry(2),\n        new THREE.MeshStandardMaterial(data)\n    );\n    ico.position.set(0, -0.5, 0);\n    ico.castShadow = true;\n    ico.receiveShadow = true;\n    ico.rotation.y = -Math.PI / Math.random() * 2;\n\n    return ico;\n};\nexport default RockFactory;\n","let AppleFactory = function () {\n    let applesGeometry = new THREE.Geometry();\n    let geometry = new THREE.SphereGeometry(0.3, 16, 16);\n\n    geometry.translate(0, 1.7, 0);\n    applesGeometry.merge(geometry);\n\n    geometry.translate(-1, -1, -1);\n    applesGeometry.merge(geometry);\n\n    geometry.translate(0, 0, 2);\n    applesGeometry.merge(geometry);\n\n    geometry.translate(2, 0, 0);\n    applesGeometry.merge(geometry);\n\n    geometry.translate(0, 0, -2);\n    applesGeometry.merge(geometry);\n\n    let buffGeometry = new THREE.BufferGeometry().fromGeometry(applesGeometry);\n    let material = new THREE.MeshStandardMaterial({ color: 0xff1122, side: THREE.DoubleSide, roughness: 1, metalness: 0 });\n    let apples = new THREE.Mesh(buffGeometry, material);\n    apples.position.set(0, 0, 0);\n    return apples;\n};\n\nlet TreeFactory = function () {\n    let cylinder = new THREE.Mesh(\n        new THREE.CylinderBufferGeometry(0.2, 0.5, 2, 32),\n        new THREE.MeshStandardMaterial({color: 0x542207, metalness: 0, roughness: 1})\n    );\n\n    let ico = new THREE.Mesh(\n        new THREE.IcosahedronBufferGeometry(2),\n        new THREE.MeshStandardMaterial({color: 0x087f23, metalness: 0, roughness: 1})\n    );\n    ico.position.set(0, 2, 0);\n    ico.castShadow = true;\n    ico.receiveShadow = true;\n    ico.name = 'top';\n\n    cylinder.add(ico);\n    ico.add(AppleFactory());\n    cylinder.castShadow = true;\n    cylinder.receiveShadow = true;\n\n    return cylinder;\n};\n\nexport default TreeFactory;\n","let KnifeFactory = () => {\n    let i = 0.5;\n\n    let shape = new THREE.Shape();\n\n    shape.lineTo(i * 1, 0);\n    shape.lineTo(i * 1, i * 4);\n    shape.bezierCurveTo (0, i * 3, 0, i * 2, 0, 0);\n\n    let mesh = new THREE.Mesh(\n        new THREE.ShapeGeometry(shape),\n        new THREE.MeshStandardMaterial({ color: 0xCBCDCD, metalness: 1, roughness: 0.5, emissive: 0x676767, side: THREE.DoubleSide })\n    );\n    mesh.position.set(0, 1.2, 0);\n    mesh.rotation.x = -Math.PI / 2;\n    mesh.castShadow = true;\n    mesh.receiveShadow = true;\n\n    let plane = new THREE.Mesh(\n        new THREE.PlaneBufferGeometry(i / 2, i * 2, 1, 1),\n        new THREE.MeshStandardMaterial({ color: 0x542207, side: THREE.DoubleSide })\n    );\n    plane.position.set(i / 2, -i, 0);\n    plane.castShadow = true;\n    plane.receiveShadow = true;\n\n    mesh.add(plane);\n    mesh.name = 'Knife';\n    return mesh;\n};\n\nexport default KnifeFactory;\n","import config from './config';\nimport AppFactory from './app-factory';\nimport ConnectionFactory from './connection-factory';\nimport test from './test';\nimport PlayerScriptFactory from './player-scripts';\nimport Entities from '../entities';\nimport KeyboardFactory from '../shared/keyboard-factory';\nimport Models from './models';\n\nlet Game = {\n    config,\n    clock: null,\n    is: {\n        ready: false,\n        connecting: false,\n        connected: false\n    },\n    ready: false,\n    quality: 0.7,\n    app: null,\n    children: {},\n    keyboard: null,\n    canvas: null,\n    models: {},\n    async initGame() {\n        for (let name in Models) {\n            Game.models[name] = Models[name]();\n        }\n        AppFactory(Game);\n        Game.setQuality();\n\n        Entities.init(Game.models);\n        Game.connection = ConnectionFactory(Game);\n        Game.connection.initSocket(Game.config.serverUrl);\n        Game.keyboard = KeyboardFactory(document.body);\n        test(Game);\n\n        Game.clock = new THREE.Clock(true);\n        Game.update();\n        await Game.getWorlds();\n        Game.is.ready = true;\n    },\n    update() {\n        requestAnimationFrame(Game.update);\n        let dt = Game.clock.getDelta();\n\n        for (let i in Game.children) {\n            Game.children[i].update(dt);\n        }\n\n        Game.app.renderer.render(Game.app.scene, Game.app.camera);\n    },\n    setQuality(pixelRatio = 0.7) {\n        Game.quality = pixelRatio;\n        Game.app.renderer.setPixelRatio(window.devicePixelRatio * Game.quality);\n        Game.app.renderer.setSize(window.innerWidth, window.innerHeight);\n    },\n    addEntity(childEntity) {\n        Game.children[childEntity.id] = childEntity;\n        childEntity.parent = Game;\n        Game.app.scene.add(childEntity.body);\n    },\n    updateWorld(worldEntities) {\n        for (let i in Game.children) {\n            if (worldEntities[i] === undefined) {\n                Game.children[i].destroy();\n            }\n        }\n\n        for (let i in worldEntities) {\n            /**\n             * Entity must be undefined and must not be the player,\n             * we will handle the creation of the creation of the player entity\n             * when the connectServer promise resolve\n             */\n            if (Game.children[i] === undefined && worldEntities[i].id !== Game.socket.id) {\n                let entity = Entities.create(worldEntities[i]);\n                Game.addEntity(entity);\n            } else {\n                if (Game.children[i] !== undefined) {\n                    Object.assign(Game.children[i], worldEntities[i]);\n                }\n            }\n        }\n    },\n    setPlayerScripts: PlayerScriptFactory,\n    async connectServer() {\n        if (Game.is.ready && !Game.is.connecting && !Game.is.connected) {\n            Game.is.connecting = true;\n            let player = await Game.connection.connectServer(Game.selectedWorld);\n            let entity = Entities.create(player);\n            Game.addEntity(entity);\n            Game.player = entity;\n            Game.setPlayerScripts(Game);\n            Game.is.connected = true;\n            Game.is.connecting = false;\n        }\n    },\n    selectedWorld: null,\n    worlds: {},\n    async getWorlds() {\n        let worlds = await Game.connection.getWorlds();\n        let selected = false;\n        for (let world in worlds) {\n            worlds[world].selected = false;\n            worlds[world].disabled = false;\n            if (\n                !selected &&\n                worlds[world].playerCount < worlds[world].maxPlayers\n            ) {\n                worlds[world].selected = true;\n                Game.selectedWorld = world;\n                selected = true;\n            }\n            if (worlds[world].playerCount >= worlds[world].maxPlayers) {\n                worlds[world].disabled = true;\n            }\n        }\n        Game.worlds = worlds;\n    },\n    selectWorld(name) {\n        for (let world in Game.worlds) {\n            if (world === name) {\n                Game.worlds[world].selected = true;\n                Game.selectedWorld = world;\n            } else {\n                Game.worlds[world].selected = false;\n            }\n        }\n    },\n    fixedProps(obj = {}, precision = 3) {\n        let o = Array.isArray(obj) ? [] : {};\n\n        for (let i in obj) {\n            if (typeof obj[i] === 'object') {\n                o[i] = Game.fixedProps(obj[i]);\n                continue;\n            }\n\n            if (typeof obj[i] === 'number') {\n                o[i] = +(obj[i]).toFixed(precision);\n                continue;\n            }\n\n            o[i] = obj[i];\n        }\n\n        return o;\n    }\n};\n\nexport default Game;\n"],"names":["let","const"],"mappings":";;;;;;;;;;;;;;CAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kBC6HuB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4BA2CI;;;;;;;;;;;;;SAavB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CCrLJC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CCAAD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CCAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CCAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CCAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CCAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CCAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CCAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KCwBU;;;;;;;;;;;;;;;SAeF;;SAEJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KA6CM;;;0BAGe;;;;;;;;SAQrB;;;KAGM;sBACW;;;;;;;;;;;;;;;;;;SAkBjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}
{"version":3,"file":"index.min.js","sources":["../../node_modules/valyrian.js/plugins/request.js","../../node_modules/valyrian.js/plugins/router.js","../../app/client/connection-factory.js","../../app/client/player-scripts/keyboard-script-factory.js","../../app/entities/tree-entity-factory.js","../../app/shared/keyboard-factory.js","../../app/client/index.js","../../app/ui/pages/home.js"],"sourcesContent":["let plugin = function (v) {\n    let Request = function (baseUrl = '', options = {}) {\n        let url = baseUrl.replace(/\\/$/gi, '').trim(),\n            opts = Object.assign({\n                methods: ['get', 'post', 'put', 'patch', 'delete']\n            }, options),\n            parseUrl;\n\n        function serialize(obj, prefix) {\n            let e = encodeURIComponent;\n            return Object.keys(obj)\n                .map((p) => {\n                    let k = prefix ? prefix + '[' + p + ']' : p;\n\n                    return typeof obj[p] === 'object'\n                        ? serialize(obj[p], k)\n                        : e(k) + '=' + e(obj[p]);\n                })\n                .join('&');\n        }\n\n        function request(method, url, data, options = {}) {\n            let opts = Object.assign({\n                    method: method.toLowerCase(),\n                    headers: {\n                        'Accept': 'application/json',\n                        'Content-Type': 'application/json'\n                    }\n                }, request.options, options),\n                type = opts.headers.Accept;\n\n            if (data !== undefined) {\n                if (opts.method === 'get' && typeof data === 'object') {\n                    url += data = serialize(data);\n                }\n\n                if (opts.method !== 'get') {\n                    opts.body = JSON.stringify(data);\n                }\n            }\n\n            return fetch(parseUrl(url), opts)\n                .then(response => {\n                    if (!response.ok) {\n                        let err = new Error(response.statusText);\n                        err.response = response;\n                        throw err;\n                    }\n\n                    if (/text/gi.test(type)) {\n                        return response.text();\n                    }\n\n                    if (/json/gi.test(type)) {\n                        return response.json();\n                    }\n\n                    return response;\n                });\n        };\n\n        parseUrl = function (url) {\n            let u = /^https?/gi.test(url)\n                ? url\n                : (request.urls.base + '/' + url).trim().replace(/^\\/\\//gi, '/').trim();\n\n            if (\n                v.is.node &&\n                typeof request.urls.node === 'string'\n            ) {\n                request.urls.node = request.urls.node.replace(/\\/$/gi, '').trim();\n\n                if (/^https?/gi.test(u) && typeof request.urls.api === 'string') {\n                    request.urls.api = request.urls.api.replace(/\\/$/gi, '').trim();\n                    u = u.replace(request.urls.api, request.urls.node);\n                }\n\n                if (!/^https?/gi.test(u)) {\n                    u = request.urls.node + u;\n                }\n            }\n\n            return u;\n        };\n\n        request.new = function (baseUrl, options) {\n            return Request(baseUrl, options);\n        };\n\n        request.urls = {};\n        request.urls.api = undefined;\n        request.urls.node = undefined;\n        request.urls.base = url;\n        request.options = opts;\n\n        opts.methods.forEach(method =>\n            request[method] = (url, data, options) => request(method, url, data, options)\n        );\n\n        return request;\n    };\n\n    v.request = Request();\n};\n\n// module.exports = plugin;\nexport default plugin;\n","/**\n * Handles the mix of single and array of middlewares\n * @method parseMiddlewares\n * @param  {Function|Array}         middlewares     // Middleware or array of middlewares\n * @param  {Array}                  [array=[]]      // The array to store the final list of middlewares\n * @return {Array}                                  // The final list of middlewares\n */\nlet parseMiddlewares = (middlewares, array = []) => {\n    if (typeof middlewares === 'function') {\n        array.push(middlewares);\n        return array;\n    }\n\n    let i = 0, l = middlewares.length;\n    for (; i < l; i++) {\n        if (Array.isArray(middlewares[i])) {\n            parseMiddlewares(middlewares[i], array);\n            continue;\n        }\n\n        array.push(middlewares[i]);\n    }\n    return array;\n};\n\n/**\n * @description Adds a path to a router\n * @method addPath\n * @param  {Router} router              The router in which to add the path\n * @param  {String} method              The method that will handle this path\n * @param  {Array} args                The mixed params (String|Function|Array)\n * @returns {Router}                    The router\n */\nlet addPath = (router, method, args) => {\n    let path, middlewares;\n\n    // Get the first argument\n    if (typeof args[0] === 'string') {\n        path = args.shift();\n    }\n\n    // If the seccond argument is a function and has paths\n    // and regexpList properties then\n    // Treat it as a subrouter\n    if (\n        typeof args[0] === 'function' &&\n        args[0].paths &&\n        args[0].regexpList\n    ) {\n        let subrouter = args.shift(),\n            i = 0,\n            l = subrouter.paths.length;\n\n        // For each path of the subrouter\n        for (; i < l; i++) {\n            let submiddlewares = subrouter.paths[i].middlewares;\n            let submethod = subrouter.paths[i].method;\n            let subpath = subrouter.paths[i].path;\n\n            // If there is a path add it as prefix to the subpath\n            if (path) {\n                subpath = path + (subpath || '*');\n            }\n\n            // If there is a subpath set it as the first element\n            // on the submiddlewares array\n            if (subpath) {\n                submiddlewares.unshift(subpath);\n            }\n\n            // Add the path to the router\n            router = addPath(router, submethod, submiddlewares);\n        }\n    }\n\n    // Parse middlwares to handle mixed arrays of middlwares and sequenced middlwares\n    middlewares = parseMiddlewares(args);\n\n    // Add the path only if there are middlewares passed\n    if (middlewares.length > 0) {\n        // If the path wasn't set before, set the regexp and params list\n        if (path && router.regexpList[path] === undefined) {\n            // Remove the last slash\n            path = path.replace(/\\/(\\?.*)?$/gi, '$1');\n\n            // Find the express like params\n            let params = path.match(/:(\\w+)?/gi) || [];\n\n            // Set the names of the params found\n            for (let i in params) {\n                params[i] = params[i].slice(1);\n            }\n\n            let regexpPath = path\n                // Catch params\n                .replace(/:(\\w+)/gi, '([^\\\\s\\\\/|\\\\?]+)')\n                // To set to any url with the path as prefix\n                .replace(/\\*/g, '.*')\n                // Remove the last slash\n                .replace(/\\/(\\?.*)?$/gi, '$1');\n\n            // Set the object to the path\n            router.regexpList[path] = {\n                regexp: new RegExp('^' + regexpPath + '/?(\\\\?.*)?$', 'gi'),\n                params: params\n            };\n        }\n\n        // Add the path to the paths list\n        router.paths.push({\n            method: method,\n            path: path,\n            middlewares: middlewares\n        });\n    }\n\n    return router;\n};\n\nlet RouterFactory = () => {\n    /**\n     * new Rotuer\n     * @param  {String}    url     The path to call\n     * @return {Any}           The final response\n     */\n    let Router = async function (url = '/') {\n        let method = 'get',\n            params = {},\n            middlewares = [],\n            response,\n            i = 0,\n            l = Router.paths.length;\n\n        Router.url = url;\n\n        for (; i < l; i++) {\n            let path = Router.paths[i];\n            if (method !== path.method && path.method !== 'use') {\n                continue;\n            }\n\n            if ((path.method === 'use' || method === path.method) && path.path === undefined) {\n                parseMiddlewares(path.middlewares, middlewares);\n                continue;\n            }\n\n            let reg = Router.regexpList[path.path];\n            let matches = reg.regexp.exec(url);\n            reg.regexp.lastIndex = -1;\n            if (Array.isArray(matches)) {\n                matches.shift();\n                let regparams = reg.params;\n                let l = regparams.length;\n                for (; l--;) {\n                    if (params[regparams[l]] === undefined) {\n                        params[regparams[l]] = matches[l];\n                    }\n                }\n                parseMiddlewares(path.middlewares, middlewares);\n            }\n        }\n\n        Router.params = params;\n\n        if (middlewares.length > 0) {\n            let i = 0, l = middlewares.length;\n            // call sequentially every middleware\n            for (; i < l; i++) {\n                response = await middlewares[i](params);\n                // If there is a response\n                // break the for block\n                if (response) {\n                    return response;\n                }\n            }\n        }\n\n        if (Router.throwNotFound) {\n            // If no response was sent to the client throw an error\n            throw new Error(`The url ${url} requested wasn't found`);\n        }\n    };\n\n    Router.url = '/';\n    Router.params = {};\n    Router.throwNotFound = true;\n\n    /**\n     * Where to store the paths and its middlewares\n     * @type {Object}\n     */\n    Router.paths = [];\n\n    /**\n     * Where to store the regexp and params list for the paths\n     * @type {[type]}\n     */\n    Router.regexpList = {};\n\n    // For each accepted method, add the method to the router\n    Router.get = function () {\n        return addPath(Router, 'get', v.utils.flat(arguments, 0, []));\n    };\n    Router.use = function () {\n        return addPath(Router, 'use', v.utils.flat(arguments, 0, []));\n    };\n\n    /**\n     * Return the new router\n     * @type {Router}\n     */\n    return Router;\n};\n\n\nlet plugin = function (v) {\n    let mainRouter;\n    let RoutesContainer;\n    function runRoute(parentComponent, url, args) {\n        return mainRouter(url)\n            .then(response => {\n                if (typeof response !== 'object') {\n                    throw new Error('v.router.component.required');\n                }\n\n                if (!response.isComponent && typeof response.view === 'function') {\n                    Object.assign(response, {isComponent: true});\n                }\n\n                if (!response.isComponent) {\n                    throw new Error('v.router.component.required');\n                }\n\n                if (parentComponent) {\n                    args.unshift(v(response, args));\n                    response = parentComponent;\n                }\n\n                args.unshift(response);\n\n                if (v.is.node || !v.is.mounted) {\n                    args.unshift(RoutesContainer);\n                    return v.mount.apply(v, args);\n                }\n\n                return v.update.apply(v, args);\n            });\n    };\n\n    v.routes = function (elementContainer, router) {\n        if (elementContainer && router) {\n            mainRouter = router;\n            RoutesContainer = elementContainer;\n            // Activate the use of the router\n            if (v.is.browser) {\n                function onPopStateGoToRoute() {\n                    v.routes.go(document.location.pathname);\n                }\n                window.addEventListener('popstate', onPopStateGoToRoute, false);\n                onPopStateGoToRoute();\n            }\n        }\n    };\n\n    v.routes.get = function () {\n        let routes = [];\n        mainRouter.paths.forEach(path => {\n            if (path.method === 'get') {\n                routes.push(path.path === '' ? '/' : path.path);\n            }\n        });\n        return routes;\n    };\n\n    v.routes.current = '/';\n    v.routes.params = {};\n\n    v.routes.go = function () {\n        let args = v.utils.flat(arguments, 0, []);\n        let parentComponent;\n        let url;\n\n        if (typeof args[0] === 'object') {\n            if (!args[0].isComponent && typeof args[0].view === 'function') {\n                args[0] = Object.assign(args[0], {isComponent: true});\n            }\n\n            if (args[0].isComponent) {\n                parentComponent = args.shift();\n            }\n        }\n\n        if (typeof args[0] === 'string') {\n            url = args.shift();\n        }\n\n        if (!url) {\n            throw new Error('v.router.url.required');\n        }\n\n        if (v.is.browser) {\n            window.history.pushState({}, '', url);\n        }\n\n        return runRoute(parentComponent, url, args);\n    };\n\n    v.Router = RouterFactory;\n};\n\n// module.exports = plugin;\nexport default plugin;\n","const ConnectionFactory = (Game) => {\n    let Connection = {\n        initSocket(url) {\n            if (Game.socket !== undefined) {\n                Game.socket.disconnect();\n                Game.socket = undefined;\n            }\n\n            Game.socket = io(url);\n\n            /**\n             * As we will destroy the player when socket disconnects\n             * with this we will reload the browser page if the user recconnects\n             */\n            Game.socket.on('reconnect', () => window.location.href = window.location.href);\n\n            // Custom game events\n            Game.socket.on('world', data => Game.updateWorld(data));\n        },\n        connectServer(world = 'Alpha') {\n            return new Promise((resolve) => {\n                Game.socket.emit('connectServer', world, (err, entity) => {\n                    if (err) {\n                        console.error(err);\n                        return;\n                    }\n                    entity.socket = Game.socket;\n                    resolve(entity);\n                });\n            });\n        },\n        getWorlds: () => new Promise((resolve) => Game.socket.emit('getWorlds', resolve))\n    };\n    return Connection;\n};\n\n\nexport default ConnectionFactory;\n","let KeyboardScriptFactory = (Game) => {\n    let raycaster = new THREE.Raycaster();\n    let mouse = new THREE.Vector2();\n    let intersects;\n\n    return () => {\n\n        let mouseData = {\n            b: Game.keyboard.mouse.b,\n            d: Game.keyboard.mouse.d\n        };\n\n        if (\n            mouse.x !== Game.keyboard.mouse.x || mouse.y !== Game.keyboard.mouse.y // Mouse moved\n            || mouseData.b.length > 0 // Button pressed\n            || mouseData.d !== 0 // Mousewheel event\n        ) {\n            mouse.x = Game.keyboard.mouse.x;\n            mouse.y = Game.keyboard.mouse.y;\n            mouseData.p = false;\n            raycaster.setFromCamera(mouse, Game.app.camera);\n            intersects = raycaster.intersectObjects([Game.app.ground]);\n            if (intersects.length === 1) {\n                mouseData.p = {\n                    x: intersects[0].point.x,\n                    y: intersects[0].point.y,\n                    z: intersects[0].point.z\n                };\n            }\n            Game.player.socket.emit('mouse', Game.fixedProps(mouseData));\n        }\n\n        if (\n            Game.keyboard.pressedKeys.length > 0 &&\n            Game.keyboard.target === Game.canvas\n        ) {\n            Game.player.socket.emit('keyboard', Game.keyboard.pressedKeys);\n        }\n    };\n};\n\nexport default KeyboardScriptFactory;\n","let TreeFactory = function () {\n    let cylinder = new THREE.Mesh(\n        new THREE.CylinderBufferGeometry(0.2, 0.5, 2, 32),\n        new THREE.MeshStandardMaterial({color: 0x542207})\n    );\n\n    let ico = new THREE.Mesh(\n        new THREE.IcosahedronBufferGeometry(2),\n        new THREE.MeshStandardMaterial({color: 0x087f23})\n    );\n    ico.position.set(0, 2, 0);\n    ico.castShadow = true;\n    ico.receiveShadow = true;\n\n    cylinder.add(ico);\n    cylinder.castShadow = true;\n    cylinder.receiveShadow = true;\n\n    let entity = new THREE.Object3D();\n    entity.add(cylinder);\n    return entity;\n};\nlet Factory = () => {\n\n    return {\n        Model: TreeFactory(),\n        initServer(entity) {\n\n        },\n        initClient(entity) {\n\n        }\n    };\n};\n\nmodule.exports = Factory;\n","/**\n * This keyboard handler will be used both sides (server and client)\n * to get the pressed keys by the user\n */\n\nlet modifiers = {\n    '⇧': 16, shift: 16,\n    '⌥': 18, alt: 18, option: 18,\n    '⌃': 17, ctrl: 17, control: 17,\n    '⌘': 91, command: 91\n};\n\nlet special = {\n    backspace: 8, tab: 9, clear: 12,\n    enter: 13, 'return': 13,\n    esc: 27, escape: 27, space: 32,\n    left: 37, up: 38,\n    right: 39, down: 40,\n    del: 46, 'delete': 46,\n    home: 36, end: 35,\n    pageup: 33, pagedown: 34,\n    ',': 188, '.': 190, '/': 191,\n    '`': 192, '-': 189, '=': 187,\n    ';': 186, '\\'': 222,\n    '[': 219, ']': 221, '\\\\': 220\n};\n\nlet f = {\n    f1: 112,\n    f2: 113,\n    f3: 114,\n    f4: 115,\n    f5: 116,\n    f6: 117,\n    f7: 118,\n    f8: 119,\n    f9: 120,\n    f10: 121,\n    f11: 122,\n    f12: 123\n};\n\nlet mouse = {\n    left: 1,\n    right: 3,\n    middle: 2\n};\n\nlet KeyboardFactory = function (element, preventContext = true) {\n    let Keyboard = {\n        target: null,\n        pressedKeys: [],\n        mouse: {\n            x: 0,\n            y: 0,\n            b: [],\n            d: 0\n        },\n        clearMouseDelta: null,\n        code(x) {\n            return special[x] ||\n                modifiers[x] ||\n                f[x] ||\n                x.toUpperCase().charCodeAt(0);\n        },\n        isKeyPressed(x) {\n            return Keyboard.pressedKeys.indexOf(Keyboard.code(x)) !== -1;\n        },\n        pressKey(key) {\n            let code = Keyboard.code(key);\n            if (Keyboard.pressedKeys.indexOf(code) === -1) {\n                Keyboard.pressedKeys.push(code);\n            }\n        },\n        isButtonPressed(x) {\n            return Keyboard.mouse.b.indexOf(mouse[x]) !== -1;\n        },\n        pressButton(x) {\n            if (Keyboard.mouse.b.indexOf(mouse[x]) === -1) {\n                Keyboard.mouse.b.push(mouse[x]);\n            }\n        },\n        keyListener(event) {\n            if (event.type === 'keydown') {\n                Keyboard.target = event.target;\n                if (Keyboard.pressedKeys.indexOf(event.keyCode) === -1) {\n                    Keyboard.pressedKeys.push(event.keyCode);\n                }\n                return;\n            }\n\n            if (event.type === 'keyup') {\n                let index = Keyboard.pressedKeys.indexOf(event.keyCode);\n                if (index !== -1) {\n                    Keyboard.pressedKeys.splice(index, 1);\n                }\n            }\n        },\n        mouseListener(event) {\n            Keyboard.target = event.target;\n            Keyboard.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n            Keyboard.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n\n            // Fix cross browser button that triggered the event\n            event.which ? event.which :\n                event.button === 1 ? 1 :\n                    event.button === 2 ? 3 :\n                        event.button === 4 ? 2 : 1;\n\n            if (event.type.indexOf('mousedown') !== -1) {\n                if (Keyboard.mouse.b.indexOf(event.which) === -1) {\n                    Keyboard.mouse.b.push(event.which);\n                }\n                return;\n            }\n\n            if (event.type.indexOf('mouseup') !== -1) {\n                let index = Keyboard.mouse.b.indexOf(event.which);\n                if (index !== -1) {\n                    Keyboard.mouse.b.splice(index, 1);\n                }\n            }\n\n            if (event.type.indexOf('mousewheel') !== -1 || event.type.indexOf('DOMMouseScroll') !== -1) {\n                let delta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));\n                Keyboard.mouse.d = delta;\n                clearTimeout(Keyboard.clearMouseDelta);\n                Keyboard.clearMouseDelta = setTimeout(() => {\n                    Keyboard.mouse.d = 0;\n                }, 150);\n            }\n        },\n        addEvent(type, handler) {\n            if (element !== undefined) {\n                let el = typeof element === 'string'\n                    ? document.querySelectorAll(element)[0]\n                    : element;\n\n                if (el.addEventListener) {\n                    el.addEventListener(type, handler, false);\n                    if (type === 'mousewheel') {\n                        el.addEventListener('DOMMouseScroll', handler, false);\n                    }\n                } else {\n                    el.attachEvent(`on${type}`, handler);\n                }\n\n            }\n        },\n        preventContext(event) {\n            event.preventDefault();\n        }\n    };\n\n    Keyboard.addEvent('keydown', Keyboard.keyListener);\n    Keyboard.addEvent('keyup', Keyboard.keyListener);\n    Keyboard.addEvent('mousemove', Keyboard.mouseListener);\n    Keyboard.addEvent('mousedown', Keyboard.mouseListener);\n    Keyboard.addEvent('mouseup', Keyboard.mouseListener);\n    Keyboard.addEvent('mousewheel', Keyboard.mouseListener);\n    Keyboard.addEvent('contextmenu', Keyboard.preventContext);\n\n    return Keyboard;\n};\n\nmodule.exports = KeyboardFactory;\n","import config from './config';\nimport AppFactory from './app-factory';\nimport ConnectionFactory from './connection-factory';\nimport test from './test';\nimport PlayerScriptFactory from './player-scripts';\nimport Entities from '../entities';\nimport KeyboardFactory from '../shared/keyboard-factory';\n\nlet Game = {\n    config,\n    deltaTime: Date.now(),\n    is: {\n        ready: false,\n        connecting: false,\n        connected: false\n    },\n    ready: false,\n    quality: 0.8,\n    app: null,\n    children: {},\n    keyboard: null,\n    canvas: null,\n    async initGame() {\n        AppFactory(Game);\n        Game.setQuality();\n\n        Entities.init();\n        Game.connection = ConnectionFactory(Game);\n        Game.connection.initSocket(Game.config.serverUrl);\n        Game.keyboard = KeyboardFactory(document.body);\n        test(Game);\n\n        Game.update();\n        await Game.getWorlds();\n        Game.is.ready = true;\n    },\n    update() {\n        let dt = (Date.now() - Game.deltaTime) * .001;\n\n        for (let i in Game.children) {\n            Game.children[i].update(dt);\n        }\n\n        Game.deltaTime = Date.now();\n        Game.app.renderer.render(Game.app.scene, Game.app.camera);\n        requestAnimationFrame(() => Game.update());\n    },\n    setQuality(pixelRatio = 0.8) {\n        Game.quality = pixelRatio;\n        Game.app.renderer.setPixelRatio(window.devicePixelRatio * Game.quality);\n        Game.app.renderer.setSize(window.innerWidth, window.innerHeight);\n    },\n    addEntity(childEntity) {\n        Game.children[childEntity.id] = childEntity;\n        childEntity.parent = Game;\n        Game.app.scene.add(childEntity.body);\n    },\n    updateWorld(world) {\n        for (let i in Game.children) {\n            if (world.children[i] === undefined) {\n                Game.children[i].destroy();\n            }\n        }\n\n        for (let i in world.children) {\n            /**\n             * Entity must be undefined and must not be the player,\n             * we will handle the creation of the creation of the player entity\n             * when the connectServer promise resolve\n             */\n            if (Game.children[i] === undefined && world.children[i].id !== Game.socket.id) {\n                let entity = Entities.create(world.children[i]);\n                Game.addEntity(entity);\n            } else {\n                if (Game.children[i] !== undefined) {\n                    Object.assign(Game.children[i], world.children[i]);\n                }\n            }\n        }\n    },\n    setPlayerScripts: PlayerScriptFactory,\n    async connectServer() {\n        if (Game.is.ready && !Game.is.connecting && !Game.is.connected) {\n            Game.is.connecting = true;\n            let player = await Game.connection.connectServer(Game.selectedWorld);\n            let entity = Entities.create(player);\n            Game.addEntity(entity);\n            Game.player = entity;\n            Game.setPlayerScripts(Game);\n            Game.is.connected = true;\n            Game.is.connecting = false;\n        }\n    },\n    selectedWorld: null,\n    worlds: {},\n    async getWorlds() {\n        let worlds = await Game.connection.getWorlds();\n        let selected = false;\n        for (let world in worlds) {\n            worlds[world].selected = false;\n            worlds[world].disabled = false;\n            if (\n                !selected &&\n                worlds[world].playerCount < worlds[world].maxPlayers\n            ) {\n                worlds[world].selected = true;\n                Game.selectedWorld = world;\n                selected = true;\n            }\n            if (worlds[world].playerCount >= worlds[world].maxPlayers) {\n                worlds[world].disabled = true;\n            }\n        }\n        Game.worlds = worlds;\n    },\n    selectWorld(name) {\n        for (let world in Game.worlds) {\n            if (world === name) {\n                Game.worlds[world].selected = true;\n                Game.selectedWorld = world;\n            } else {\n                Game.worlds[world].selected = false;\n            }\n        }\n    },\n    fixedProps(obj = {}, precision = 3) {\n        let o = Array.isArray(obj) ? [] : {};\n\n        for (let i in obj) {\n            if (typeof obj[i] === 'object') {\n                o[i] = Game.fixedProps(obj[i]);\n                continue;\n            }\n\n            if (typeof obj[i] === 'number') {\n                o[i] = +(obj[i]).toFixed(precision);\n                continue;\n            }\n\n            o[i] = obj[i];\n        }\n\n        return o;\n    }\n};\n\nexport default Game;\n","import logo from '../../../public/imgs/icon.svg';\nimport {Panel} from '../components';\nimport Game from '../../client';\n\nlet Page = {\n    autologin: true,\n    getOptions() {\n        let options = [];\n        for (let name in Game.worlds) {\n            let world = Game.worlds[name];\n            options.push(\n                <option value={name} disabled={world.disabled} selected={world.selected}>\n                    World {name} - ({world.playerCount}/{world.maxPlayers})\n                </option>\n            );\n        }\n        return options;\n    },\n    selectWorld(e) {\n        Game.selectWorld(e.target.value);\n    },\n    async play() {\n        await Game.connectServer();\n        v.routes.go('/game');\n    },\n    onupdate() {\n        if (Game.player) {\n            v.routes.go('/game');\n            return;\n        }\n\n        if (Page.autologin && Game.is.ready && !Game.is.connecting && !Game.is.connected) {\n            Page.play();\n        }\n    },\n    view() {\n        return <article onupdate={Page.onupdate}>\n            <Panel position=\"center middle\">\n                {/* {v.trust(logo)} */}\n                <div data-flex=\"\">\n                    <Panel position=\"inline\" color=\"white\">\n                        <input placeholder=\"Player name\"/>\n                        <select onchange={Page.selectWorld}>\n                            {Page.getOptions()}\n                        </select>\n                        <button\n                            onclick={Page.play}\n                            data-background=\"success\"\n                            disabled={!Game.is.ready || Game.is.connecting}\n                            class=\"w100\">\n                            {Game.is.connecting ? 'Connecting...' : Game.is.ready ? 'Play' : 'Loading...'}\n                        </button>\n                    </Panel>\n                    <Panel position=\"inline\" color=\"white\">\n                        How to play\n                    </Panel>\n                    <Panel position=\"inline\" color=\"white\">\n                        Best scores\n                    </Panel>\n                </div>\n            </Panel>\n        </article>;\n    }\n};\n\nexport default Page;\n"],"names":["let","const"],"mappings":";;;;;;;;;;;;;;CAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kBC6HuB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4BA2CI;;;;;;;;;;;;;SAavB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CCrLJC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CCAAD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CCAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CCAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KCsBU;;;;;;;;;;SAWF;;SAEJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KA8CM;;;0BAGe;;;;;;;;SAQrB;;;KAGM;sBACW;;;;;;;;;;;;;;;;;;SAkBjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KC7FM;SACF;;SAEJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}